{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"getUserOperationGasPrice.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/actions/pimlico/getUserOperationGasPrice.ts"],"sourcesContent":["import type { Account, Chain, Client, Transport } from \"viem\"\nimport type { PimlicoRpcSchema } from \"../../types/pimlico.js\"\n\nexport type GetUserOperationGasPriceReturnType = {\n    slow: {\n        maxFeePerGas: bigint\n        maxPriorityFeePerGas: bigint\n    }\n    standard: {\n        maxFeePerGas: bigint\n        maxPriorityFeePerGas: bigint\n    }\n    fast: {\n        maxFeePerGas: bigint\n        maxPriorityFeePerGas: bigint\n    }\n}\n\n/**\n * Returns the live gas prices that you can use to send a user operation.\n *\n * - Docs: https://docs.pimlico.io/permissionless/reference/pimlico-bundler-actions/getUserOperationGasPrice\n *\n * @param client that you created using viem's createClient whose transport url is pointing to the Pimlico's bundler.\n * @returns slow, standard & fast values for maxFeePerGas & maxPriorityFeePerGas\n *\n *\n * @example\n * import { createClient } from \"viem\"\n * import { getUserOperationGasPrice } from \"permissionless/actions/pimlico\"\n *\n * const bundlerClient = createClient({\n *      chain: goerli,\n *      transport: http(\"https://api.pimlico.io/v2/goerli/rpc?apikey=YOUR_API_KEY_HERE\")\n * })\n *\n * await getUserOperationGasPrice(bundlerClient)\n *\n */\nexport const getUserOperationGasPrice = async (\n    client: Client<\n        Transport,\n        Chain | undefined,\n        Account | undefined,\n        PimlicoRpcSchema\n    >\n): Promise<GetUserOperationGasPriceReturnType> => {\n    const gasPrice = await client.request({\n        method: \"pimlico_getUserOperationGasPrice\",\n        params: []\n    })\n\n    return {\n        slow: {\n            maxFeePerGas: BigInt(gasPrice.slow.maxFeePerGas),\n            maxPriorityFeePerGas: BigInt(gasPrice.slow.maxPriorityFeePerGas)\n        },\n        standard: {\n            maxFeePerGas: BigInt(gasPrice.standard.maxFeePerGas),\n            maxPriorityFeePerGas: BigInt(gasPrice.standard.maxPriorityFeePerGas)\n        },\n        fast: {\n            maxFeePerGas: BigInt(gasPrice.fast.maxFeePerGas),\n            maxPriorityFeePerGas: BigInt(gasPrice.fast.maxPriorityFeePerGas)\n        }\n    }\n}\n"],"names":[],"mappings":"AAkBA;;;;;;;;;;;;;;;;;;;;GAoBG;;;AACI,MAAM,wBAAwB,GAAG,KAAK,EACzC,MAKC,EAC0C,EAAE;IAC7C,MAAM,QAAQ,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC;QAClC,MAAM,EAAE,kCAAkC;QAC1C,MAAM,EAAE,EAAE;KACb,CAAC,CAAA;IAEF,OAAO;QACH,IAAI,EAAE;YACF,YAAY,EAAE,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC;YAChD,oBAAoB,EAAE,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,oBAAoB,CAAC;SACnE;QACD,QAAQ,EAAE;YACN,YAAY,EAAE,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,YAAY,CAAC;YACpD,oBAAoB,EAAE,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,oBAAoB,CAAC;SACvE;QACD,IAAI,EAAE;YACF,YAAY,EAAE,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC;YAChD,oBAAoB,EAAE,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,oBAAoB,CAAC;SACnE;KACJ,CAAA;AACL,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 50, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 56, "column": 0}, "map": {"version":3,"file":"getUserOperationStatus.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/actions/pimlico/getUserOperationStatus.ts"],"sourcesContent":["import type { Account, Chain, Client, Hash, Transport } from \"viem\"\nimport type {\n    PimlicoRpcSchema,\n    PimlicoUserOperationStatus\n} from \"../../types/pimlico.js\"\n\nexport type GetUserOperationStatusParameters = {\n    hash: Hash\n}\n\nexport type GetUserOperationStatusReturnType = PimlicoUserOperationStatus\n\n/**\n * Returns the status of the userOperation that is pending in the mempool.\n *\n * - Docs: https://docs.pimlico.io/permissionless/reference/pimlico-bundler-actions/getUserOperationStatus\n *\n * @param client {@link PimlicoClient} that you created using viem's createClient whose transport url is pointing to the Pimlico's bundler.\n * @param hash {@link Hash} UserOpHash that you must have received from sendUserOperation.\n * @returns status & transaction hash if included {@link GetUserOperationStatusReturnType}\n *\n *\n * @example\n * import { createClient } from \"viem\"\n * import { getUserOperationStatus } from \"permissionless/actions/pimlico\"\n * import { pimlicoBundlerActions } from 'permissionless/actions/pimlico'\n *\n * const bundlerClient = createClient({\n *      chain: goerli,\n *      transport: http(\"https://api.pimlico.io/v2/goerli/rpc?apikey=YOUR_API_KEY_HERE\")\n * }).extend(pimlicoBundlerActions)\n *\n * await getUserOperationStatus(bundlerClient, { hash: userOpHash })\n *\n */\nexport const getUserOperationStatus = async (\n    client: Client<\n        Transport,\n        Chain | undefined,\n        Account | undefined,\n        PimlicoRpcSchema\n    >,\n    { hash }: GetUserOperationStatusParameters\n): Promise<GetUserOperationStatusReturnType> => {\n    return client.request({\n        method: \"pimlico_getUserOperationStatus\",\n        params: [hash]\n    })\n}\n"],"names":[],"mappings":"AAYA;;;;;;;;;;;;;;;;;;;;;;GAsBG;;;AACI,MAAM,sBAAsB,GAAG,KAAK,EACvC,MAKC,EACD,EAAE,IAAI,EAAoC,EACD,EAAE;IAC3C,OAAO,MAAM,CAAC,OAAO,CAAC;QAClB,MAAM,EAAE,gCAAgC;QACxC,MAAM,EAAE;YAAC,IAAI;SAAC;KACjB,CAAC,CAAA;AACN,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 95, "column": 0}, "map": {"version":3,"file":"sendCompressedUserOperation.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/actions/pimlico/sendCompressedUserOperation.ts"],"sourcesContent":["import type {\n    Account,\n    Address,\n    Chain,\n    Client,\n    Hash,\n    Hex,\n    Transport\n} from \"viem\"\nimport type { PimlicoRpcSchema } from \"../../types/pimlico.js\"\n\nexport type SendCompressedUserOperationParameters = {\n    compressedUserOperation: Hex\n    inflatorAddress: Address\n    entryPointAddress: Address\n}\n\n/**\n * @deprecated pimlico_sendCompressedUserOperation has been deprecated due to EIP-4844 blobs. Please use sendUserOperation instead.\n * Sends a compressed user operation to the bundler\n *\n * - Docs: https://docs.pimlico.io/permissionless/reference/pimlico-bundler-actions/sendCompressedUserOperation\n *\n * @param client {@link PimlicoBundlerClient} that you created using viem's createClient whose transport url is pointing to the Pimlico's bundler.\n * @param args {@link SendCompressedUserOperationParameters}.\n * @returns UserOpHash that you can use to track user operation as {@link Hash}.\n *\n * @example\n * import { pimlicoBundlerActions, sendCompressedUserOperation } from 'permissionless/actions/pimlico'\n * import { createClient } from \"viem\"\n *\n * const bundlerClient = createClient({\n *      chain: goerli,\n *      transport: http(\"https://api.pimlico.io/v2/goerli/rpc?apikey=YOUR_API_KEY_HERE\")\n * }).extend(pimlicoBundlerActions(entryPoint))\n *\n * const userOpHash = await sendCompressedUserOperation(bundlerClient, {\n *     compressedUserOperation,\n *     inflatorAddress,\n *     entryPoint\n * })\n * // Return '0xe9fad2cd67f9ca1d0b7a6513b2a42066784c8df938518da2b51bb8cc9a89ea34'\n */\nexport const sendCompressedUserOperation = async (\n    client: Client<\n        Transport,\n        Chain | undefined,\n        Account | undefined,\n        PimlicoRpcSchema\n    >,\n    args: SendCompressedUserOperationParameters\n): Promise<Hash> => {\n    const { compressedUserOperation, inflatorAddress, entryPointAddress } = args\n\n    return client.request({\n        method: \"pimlico_sendCompressedUserOperation\",\n        params: [compressedUserOperation, inflatorAddress, entryPointAddress]\n    })\n}\n"],"names":[],"mappings":"AAiBA;;;;;;;;;;;;;;;;;;;;;;;;;GAyBG;;;AACI,MAAM,2BAA2B,GAAG,KAAK,EAC5C,MAKC,EACD,IAA2C,EAC9B,EAAE;IACf,MAAM,EAAE,uBAAuB,EAAE,eAAe,EAAE,iBAAiB,EAAE,GAAG,IAAI,CAAA;IAE5E,OAAO,MAAM,CAAC,OAAO,CAAC;QAClB,MAAM,EAAE,qCAAqC;QAC7C,MAAM,EAAE;YAAC,uBAAuB;YAAE,eAAe;YAAE,iBAAiB;SAAC;KACxE,CAAC,CAAA;AACN,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 134, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"file":"deepHexlify.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/utils/deepHexlify.ts"],"sourcesContent":["import { toHex } from \"viem\"\n\nexport const transactionReceiptStatus = {\n    \"0x0\": \"reverted\",\n    \"0x1\": \"success\"\n} as const\n\n// biome-ignore lint/suspicious/noExplicitAny: it's a recursive function, so it's hard to type\nexport function deepHexlify(obj: any): any {\n    if (typeof obj === \"function\") {\n        return undefined\n    }\n    if (obj == null || typeof obj === \"string\" || typeof obj === \"boolean\") {\n        return obj\n    }\n\n    if (typeof obj === \"bigint\") {\n        return toHex(obj)\n    }\n\n    if (obj._isBigNumber != null || typeof obj !== \"object\") {\n        return toHex(obj).replace(/^0x0/, \"0x\")\n    }\n    if (Array.isArray(obj)) {\n        return obj.map((member) => deepHexlify(member))\n    }\n    return Object.keys(obj).reduce(\n        // biome-ignore lint/suspicious/noExplicitAny: it's a recursive function, so it's hard to type\n        (set: any, key: string) => {\n            set[key] = deepHexlify(obj[key])\n            return set\n        },\n        {}\n    )\n}\n"],"names":[],"mappings":";;;;AAAA,OAAO,EAAE,KAAK,EAAE,MAAM,MAAM,CAAA;;AAErB,MAAM,wBAAwB,GAAG;IACpC,KAAK,EAAE,UAAU;IACjB,KAAK,EAAE,SAAS;CACV,CAAA;AAGJ,SAAU,WAAW,CAAC,GAAQ;IAChC,IAAI,OAAO,GAAG,KAAK,UAAU,EAAE,CAAC;QAC5B,OAAO,SAAS,CAAA;IACpB,CAAC;IACD,IAAI,GAAG,IAAI,IAAI,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,OAAO,GAAG,KAAK,SAAS,EAAE,CAAC;QACrE,OAAO,GAAG,CAAA;IACd,CAAC;IAED,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE,CAAC;QAC1B,yKAAO,QAAK,AAAL,EAAM,GAAG,CAAC,CAAA;IACrB,CAAC;IAED,IAAI,GAAG,CAAC,YAAY,IAAI,IAAI,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE,CAAC;QACtD,QAAO,yKAAA,AAAK,EAAC,GAAG,CAAC,CAAC,OAAO,CAAC,MAAM,EAAE,IAAI,CAAC,CAAA;IAC3C,CAAC;IACD,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;QACrB,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAG,CAAD,UAAY,CAAC,MAAM,CAAC,CAAC,CAAA;IACnD,CAAC;IACD,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,CAC1B,8FAA8F;IAC9F,CAAC,GAAQ,EAAE,GAAW,EAAE,EAAE;QACtB,GAAG,CAAC,GAAG,CAAC,GAAG,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAA;QAChC,OAAO,GAAG,CAAA;IACd,CAAC,EACD,CAAA,CAAE,CACL,CAAA;AACL,CAAC","ignoreList":[0]}},
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 178, "column": 0}, "map": {"version":3,"file":"sponsorUserOperation.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/actions/pimlico/sponsorUserOperation.ts"],"sourcesContent":["import type {\n    Account,\n    Address,\n    Chain,\n    Client,\n    Hex,\n    OneOf,\n    PartialBy,\n    Transport\n} from \"viem\"\nimport type { UserOperation } from \"viem/account-abstraction\"\nimport type { PimlicoRpcSchema } from \"../../types/pimlico.js\"\nimport { deepHexlify } from \"../../utils/deepHexlify.js\"\n\nexport type PimlicoSponsorUserOperationParameters<\n    entryPointVersion extends \"0.6\" | \"0.7\"\n> = {\n    userOperation: OneOf<\n        | (entryPointVersion extends \"0.6\"\n              ? PartialBy<\n                    UserOperation<\"0.6\">,\n                    | \"callGasLimit\"\n                    | \"preVerificationGas\"\n                    | \"verificationGasLimit\"\n                >\n              : never)\n        | (entryPointVersion extends \"0.7\"\n              ? PartialBy<\n                    UserOperation<\"0.7\">,\n                    | \"callGasLimit\"\n                    | \"preVerificationGas\"\n                    | \"verificationGasLimit\"\n                    | \"paymasterVerificationGasLimit\"\n                    | \"paymasterPostOpGasLimit\"\n                >\n              : never)\n    >\n    entryPoint: {\n        address: Address\n        version: entryPointVersion\n    }\n    sponsorshipPolicyId?: string\n}\n\nexport type SponsorUserOperationReturnType<\n    entryPointVersion extends \"0.6\" | \"0.7\" = \"0.7\"\n> = OneOf<\n    | (entryPointVersion extends \"0.6\"\n          ? {\n                callGasLimit: bigint\n                verificationGasLimit: bigint\n                preVerificationGas: bigint\n                paymasterAndData: Hex\n            }\n          : never)\n    | (entryPointVersion extends \"0.7\"\n          ? {\n                callGasLimit: bigint\n                verificationGasLimit: bigint\n                preVerificationGas: bigint\n                paymaster: Address\n                paymasterVerificationGasLimit: bigint\n                paymasterPostOpGasLimit: bigint\n                paymasterData: Hex\n            }\n          : never)\n>\n\n/**\n * @deprecated Use `getPaymasterData` instead\n */\nexport const sponsorUserOperation = async <\n    entryPointVersion extends \"0.6\" | \"0.7\" = \"0.6\" | \"0.7\"\n>(\n    client: Client<\n        Transport,\n        Chain | undefined,\n        Account | undefined,\n        PimlicoRpcSchema<entryPointVersion>\n    >,\n    args: PimlicoSponsorUserOperationParameters<entryPointVersion>\n): Promise<SponsorUserOperationReturnType<entryPointVersion>> => {\n    const response = await client.request({\n        method: \"pm_sponsorUserOperation\",\n        params: args.sponsorshipPolicyId\n            ? [\n                  deepHexlify(args.userOperation),\n                  args.entryPoint.address,\n                  {\n                      sponsorshipPolicyId: args.sponsorshipPolicyId\n                  }\n              ]\n            : [deepHexlify(args.userOperation), args.entryPoint.address]\n    })\n\n    if (args.entryPoint.version === \"0.6\") {\n        const responseV06 = response as {\n            paymasterAndData: Hex\n            preVerificationGas: Hex\n            verificationGasLimit: Hex\n            callGasLimit: Hex\n            paymaster?: never\n            paymasterVerificationGasLimit?: never\n            paymasterPostOpGasLimit?: never\n            paymasterData?: never\n        }\n        return {\n            paymasterAndData: responseV06.paymasterAndData,\n            preVerificationGas: BigInt(responseV06.preVerificationGas),\n            verificationGasLimit: BigInt(responseV06.verificationGasLimit),\n            callGasLimit: BigInt(responseV06.callGasLimit)\n        } as SponsorUserOperationReturnType<entryPointVersion>\n    }\n\n    const responseV07 = response as {\n        preVerificationGas: Hex\n        verificationGasLimit: Hex\n        callGasLimit: Hex\n        paymaster: Address\n        paymasterVerificationGasLimit: Hex\n        paymasterPostOpGasLimit: Hex\n        paymasterData: Hex\n        paymasterAndData?: never\n    }\n\n    return {\n        callGasLimit: BigInt(responseV07.callGasLimit),\n        verificationGasLimit: BigInt(responseV07.verificationGasLimit),\n        preVerificationGas: BigInt(responseV07.preVerificationGas),\n        paymaster: responseV07.paymaster,\n        paymasterVerificationGasLimit: BigInt(\n            responseV07.paymasterVerificationGasLimit\n        ),\n        paymasterPostOpGasLimit: BigInt(responseV07.paymasterPostOpGasLimit),\n        paymasterData: responseV07.paymasterData\n    } as SponsorUserOperationReturnType<entryPointVersion>\n}\n"],"names":[],"mappings":";;;AAYA,OAAO,EAAE,WAAW,EAAE,MAAM,4BAA4B,CAAA;;AA2DjD,MAAM,oBAAoB,GAAG,KAAK,EAGrC,MAKC,EACD,IAA8D,EACJ,EAAE;IAC5D,MAAM,QAAQ,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC;QAClC,MAAM,EAAE,yBAAyB;QACjC,MAAM,EAAE,IAAI,CAAC,mBAAmB,GAC1B;YACI,oLAAA,AAAW,EAAC,IAAI,CAAC,aAAa,CAAC;YAC/B,IAAI,CAAC,UAAU,CAAC,OAAO;YACvB;gBACI,mBAAmB,EAAE,IAAI,CAAC,mBAAmB;aAChD;SACJ,GACD;YAAC,oLAAA,AAAW,EAAC,IAAI,CAAC,aAAa,CAAC;YAAE,IAAI,CAAC,UAAU,CAAC,OAAO;SAAC;KACnE,CAAC,CAAA;IAEF,IAAI,IAAI,CAAC,UAAU,CAAC,OAAO,KAAK,KAAK,EAAE,CAAC;QACpC,MAAM,WAAW,GAAG,QASnB,CAAA;QACD,OAAO;YACH,gBAAgB,EAAE,WAAW,CAAC,gBAAgB;YAC9C,kBAAkB,EAAE,MAAM,CAAC,WAAW,CAAC,kBAAkB,CAAC;YAC1D,oBAAoB,EAAE,MAAM,CAAC,WAAW,CAAC,oBAAoB,CAAC;YAC9D,YAAY,EAAE,MAAM,CAAC,WAAW,CAAC,YAAY,CAAC;SACI,CAAA;IAC1D,CAAC;IAED,MAAM,WAAW,GAAG,QASnB,CAAA;IAED,OAAO;QACH,YAAY,EAAE,MAAM,CAAC,WAAW,CAAC,YAAY,CAAC;QAC9C,oBAAoB,EAAE,MAAM,CAAC,WAAW,CAAC,oBAAoB,CAAC;QAC9D,kBAAkB,EAAE,MAAM,CAAC,WAAW,CAAC,kBAAkB,CAAC;QAC1D,SAAS,EAAE,WAAW,CAAC,SAAS;QAChC,6BAA6B,EAAE,MAAM,CACjC,WAAW,CAAC,6BAA6B,CAC5C;QACD,uBAAuB,EAAE,MAAM,CAAC,WAAW,CAAC,uBAAuB,CAAC;QACpE,aAAa,EAAE,WAAW,CAAC,aAAa;KACU,CAAA;AAC1D,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 217, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 223, "column": 0}, "map": {"version":3,"file":"validateSponsorshipPolicies.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/actions/pimlico/validateSponsorshipPolicies.ts"],"sourcesContent":["import type { Account, Address, Chain, Client, Transport } from \"viem\"\nimport type { UserOperation } from \"viem/account-abstraction\"\nimport type { PimlicoRpcSchema } from \"../../types/pimlico.js\"\nimport { deepHexlify } from \"../../utils/deepHexlify.js\"\n\nexport type ValidateSponsorshipPoliciesParameters = {\n    userOperation: UserOperation\n    entryPointAddress: Address\n    sponsorshipPolicyIds: string[]\n}\n\nexport type ValidateSponsorshipPolicies = {\n    sponsorshipPolicyId: string\n    data: {\n        name: string | null\n        author: string | null\n        icon: string | null\n        description: string | null\n    }\n}\n\n/**\n * Returns valid sponsorship policies for a userOperation from the list of ids passed\n * - Docs: https://docs.pimlico.io/permissionless/reference/pimlico-paymaster-actions/ValidateSponsorshipPolicies\n *\n * @param client {@link PimlicoBundlerClient} that you created using viem's createClient whose transport url is pointing to the Pimlico's bundler.\n * @param args {@link ValidateSponsorshipPoliciesParameters} UserOperation you want to sponsor & entryPoint.\n * @returns valid sponsorship policies, see {@link ValidateSponsorshipPolicies}\n *\n * @example\n * import { createClient } from \"viem\"\n * import { validateSponsorshipPolicies } from \"permissionless/actions/pimlico\"\n *\n * const bundlerClient = createClient({\n *   chain: goerli,\n *   transport: http(\"https://api.pimlico.io/v2/goerli/rpc?apikey=YOUR_API_KEY_HERE\")\n * })\n *\n * await validateSponsorshipPolicies(bundlerClient, {\n *   userOperation: userOperationWithDummySignature,\n *   entryPoint: entryPoint,\n *   sponsorshipPolicyIds: [\"sp_shiny_puma\"]\n * })\n * Returns\n * [\n *   {\n *     sponsorshipPolicyId: \"sp_shiny_puma\",\n *     data: {\n *       name: \"Shiny Puma\",\n *       author: \"Pimlico\",\n *       icon: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4...\",\n *       description: \"This policy is for testing purposes only\"\n *    }\n *   }\n * ]\n */\nexport const validateSponsorshipPolicies = async (\n    client: Client<\n        Transport,\n        Chain | undefined,\n        Account | undefined,\n        PimlicoRpcSchema\n    >,\n    args: ValidateSponsorshipPoliciesParameters\n): Promise<ValidateSponsorshipPolicies[]> => {\n    return await client.request({\n        method: \"pm_validateSponsorshipPolicies\",\n        params: [\n            deepHexlify(args.userOperation),\n            args.entryPointAddress,\n            args.sponsorshipPolicyIds\n        ]\n    })\n}\n"],"names":[],"mappings":";;;AAGA,OAAO,EAAE,WAAW,EAAE,MAAM,4BAA4B,CAAA;;AAqDjD,MAAM,2BAA2B,GAAG,KAAK,EAC5C,MAKC,EACD,IAA2C,EACL,EAAE;IACxC,OAAO,MAAM,MAAM,CAAC,OAAO,CAAC;QACxB,MAAM,EAAE,gCAAgC;QACxC,MAAM,EAAE;kLACJ,cAAA,AAAW,EAAC,IAAI,CAAC,aAAa,CAAC;YAC/B,IAAI,CAAC,iBAAiB;YACtB,IAAI,CAAC,oBAAoB;SAC5B;KACJ,CAAC,CAAA;AACN,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 238, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 244, "column": 0}, "map": {"version":3,"file":"getTokenQuotes.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/actions/pimlico/getTokenQuotes.ts"],"sourcesContent":["import {\n    type Account,\n    type Address,\n    type Chain,\n    ChainNotFoundError,\n    type Client,\n    type GetChainParameter,\n    type Transport,\n    hexToBigInt,\n    numberToHex\n} from \"viem\"\nimport type { PimlicoRpcSchema } from \"../../types/pimlico.js\"\n\nexport type GetTokenQuotesParameters<\n    TChain extends Chain | undefined,\n    TChainOverride extends Chain | undefined = Chain | undefined\n> = {\n    tokens: Address[]\n    entryPointAddress: Address\n} & GetChainParameter<TChain, TChainOverride>\n\nexport type GetTokenQuotesReturnType = {\n    paymaster: Address\n    token: Address\n    postOpGas: bigint\n    exchangeRate: bigint\n    exchangeRateNativeToUsd: bigint\n    balanceSlot?: bigint\n    allowanceSlot?: bigint\n}[]\n\n/**\n * Returns all related fields to calculate the potential cost of a userOperation in ERC-20 tokens.\n *\n * - Docs: https://docs.pimlico.io/permissionless/reference/pimlico-bundler-actions/getTokenQuotes\n *\n * @param client that you created using viem's createClient whose transport url is pointing to the Pimlico's bundler.\n * @returns slow, standard & fast values for maxFeePerGas & maxPriorityFeePerGas\n * @returns quotes, see {@link GetTokenQuotesReturnType}\n *\n */\nexport const getTokenQuotes = async <\n    TChain extends Chain | undefined,\n    TTransport extends Transport = Transport,\n    TChainOverride extends Chain | undefined = Chain | undefined\n>(\n    client: Client<TTransport, TChain, Account | undefined, PimlicoRpcSchema>,\n    args: GetTokenQuotesParameters<TChain, TChainOverride>\n): Promise<GetTokenQuotesReturnType> => {\n    const chainId = args.chain?.id ?? client.chain?.id\n\n    if (!chainId) {\n        throw new ChainNotFoundError()\n    }\n\n    const res = await client.request({\n        method: \"pimlico_getTokenQuotes\",\n        params: [\n            { tokens: args.tokens },\n            args.entryPointAddress,\n            numberToHex(chainId)\n        ]\n    })\n\n    return res.quotes.map((quote) => ({\n        ...quote,\n        balanceSlot: quote.balanceSlot\n            ? hexToBigInt(quote.balanceSlot)\n            : undefined,\n        allowanceSlot: quote.allowanceSlot\n            ? hexToBigInt(quote.allowanceSlot)\n            : undefined,\n        postOpGas: hexToBigInt(quote.postOpGas),\n        exchangeRate: hexToBigInt(quote.exchangeRate),\n        exchangeRateNativeToUsd: hexToBigInt(quote.exchangeRateNativeToUsd)\n    }))\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAIH,kBAAkB,EAIlB,WAAW,EACX,WAAW,EACd,MAAM,MAAM,CAAA;;;;AA+BN,MAAM,cAAc,GAAG,KAAK,EAK/B,MAAyE,EACzE,IAAsD,EACrB,EAAE;IACnC,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,EAAE,EAAE,IAAI,MAAM,CAAC,KAAK,EAAE,EAAE,CAAA;IAElD,IAAI,CAAC,OAAO,EAAE,CAAC;QACX,MAAM,IAAI,wKAAkB,EAAE,CAAA;IAClC,CAAC;IAED,MAAM,GAAG,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC;QAC7B,MAAM,EAAE,wBAAwB;QAChC,MAAM,EAAE;YACJ;gBAAE,MAAM,EAAE,IAAI,CAAC,MAAM;YAAA,CAAE;YACvB,IAAI,CAAC,iBAAiB;8KACtB,cAAA,AAAW,EAAC,OAAO,CAAC;SACvB;KACJ,CAAC,CAAA;IAEF,OAAO,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,CAAG,CAAD,AAAE;YAC9B,GAAG,KAAK;YACR,WAAW,EAAE,KAAK,CAAC,WAAW,IACxB,iLAAA,AAAW,EAAC,KAAK,CAAC,WAAW,CAAC,GAC9B,SAAS;YACf,aAAa,EAAE,KAAK,CAAC,aAAa,uKAC5B,cAAA,AAAW,EAAC,KAAK,CAAC,aAAa,CAAC,GAChC,SAAS;YACf,SAAS,GAAE,iLAAA,AAAW,EAAC,KAAK,CAAC,SAAS,CAAC;YACvC,YAAY,sKAAE,cAAA,AAAW,EAAC,KAAK,CAAC,YAAY,CAAC;YAC7C,uBAAuB,sKAAE,cAAA,AAAW,EAAC,KAAK,CAAC,uBAAuB,CAAC;SACtE,CAAC,CAAC,CAAA;AACP,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 275, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 281, "column": 0}, "map": {"version":3,"file":"pimlico.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/clients/decorators/pimlico.ts"],"sourcesContent":["import type { Address, Chain, Client, Hash, Prettify, Transport } from \"viem\"\nimport {\n    type GetTokenQuotesParameters,\n    type GetTokenQuotesReturnType,\n    type SendCompressedUserOperationParameters,\n    type ValidateSponsorshipPolicies,\n    type ValidateSponsorshipPoliciesParameters,\n    getTokenQuotes,\n    sendCompressedUserOperation,\n    validateSponsorshipPolicies\n} from \"../../actions/pimlico.js\"\nimport {\n    type GetUserOperationGasPriceReturnType,\n    getUserOperationGasPrice\n} from \"../../actions/pimlico/getUserOperationGasPrice.js\"\nimport {\n    type GetUserOperationStatusParameters,\n    type GetUserOperationStatusReturnType,\n    getUserOperationStatus\n} from \"../../actions/pimlico/getUserOperationStatus.js\"\nimport {\n    type PimlicoSponsorUserOperationParameters,\n    type SponsorUserOperationReturnType,\n    sponsorUserOperation\n} from \"../../actions/pimlico/sponsorUserOperation.js\"\n\nexport type PimlicoActions<\n    TChain extends Chain | undefined,\n    entryPointVersion extends \"0.6\" | \"0.7\" = \"0.6\" | \"0.7\"\n> = {\n    /**\n     * Returns the live gas prices that you can use to send a user operation.\n     *\n     * - Docs: https://docs.pimlico.io/permissionless/reference/pimlico-bundler-actions/getUserOperationGasPrice\n     *\n     * @returns slow, standard & fast values for maxFeePerGas & maxPriorityFeePerGas {@link GetUserOperationGasPriceReturnType}\n     *\n     * @example\n     *\n     * import { createClient } from \"viem\"\n     * import { pimlicoBundlerActions } from \"permissionless/actions/pimlico\"\n     *\n     * const bundlerClient = createClient({\n     *      chain: goerli,\n     *      transport: http(\"https://api.pimlico.io/v2/goerli/rpc?apikey=YOUR_API_KEY_HERE\")\n     * }).extend(pimlicoBundlerActions)\n     *\n     * await bundlerClient.getUserOperationGasPrice()\n     */\n    getUserOperationGasPrice: () => Promise<\n        Prettify<GetUserOperationGasPriceReturnType>\n    >\n    /**\n     * Returns the status of the userOperation that is pending in the mempool.\n     *\n     * - Docs: https://docs.pimlico.io/permissionless/reference/pimlico-bundler-actions/getUserOperationStatus\n     *\n     * @param hash {@link Hash} UserOpHash that you must have received from sendUserOperation.\n     * @returns status & transaction hash if included {@link GetUserOperationStatusReturnType}\n     *\n     * @example\n     * import { createClient } from \"viem\"\n     * import { pimlicoBundlerActions } from \"permissionless/actions/pimlico\"\n     *\n     * const bundlerClient = createClient({\n     *      chain: goerli,\n     *      transport: http(\"https://api.pimlico.io/v2/goerli/rpc?apikey=YOUR_API_KEY_HERE\")\n     * }).extend(pimlicoBundlerActions)\n     *\n     * await bundlerClient.getUserOperationStatus({ hash: userOpHash })\n     */\n    getUserOperationStatus: (\n        args: Prettify<GetUserOperationStatusParameters>\n    ) => Promise<Prettify<GetUserOperationStatusReturnType>>\n    /**\n     * @deprecated pimlico_sendCompressedUserOperation has been deprecated due to EIP-4844 blobs. Please use sendUserOperation instead.\n     * Sends a compressed user operation to the bundler\n     *\n     * - Docs: https://docs.pimlico.io/permissionless/reference/pimlico-bundler-actions/sendCompressedUserOperation\n     *\n     * @param args {@link SendCompressedUserOperationParameters}.\n     * @returns UserOpHash that you can use to track user operation as {@link Hash}.\n     *\n     * @example\n     * import { createClient } from \"viem\"\n     * import { pimlicoBundlerActions } from \"permissionless/actions/pimlico\"\n     *\n     * const bundlerClient = createClient({\n     *      chain: goerli,\n     *      transport: http(\"https://api.pimlico.io/v1/goerli/rpc?apikey=YOUR_API_KEY_HERE\")\n     * }).extend(pimlicoBundlerActions)\n     *\n     * const userOpHash = await bundlerClient.sendCompressedUserOperation({\n     *     compressedUserOperation,\n     *     inflatorAddress,\n     *     entryPoint\n     * })\n     * // Return '0xe9fad2cd67f9ca1d0b7a6513b2a42066784c8df938518da2b51bb8cc9a89ea34'\n     */\n    sendCompressedUserOperation: (\n        args: Prettify<\n            Omit<SendCompressedUserOperationParameters, \"entryPointAddress\">\n        >\n    ) => Promise<Hash>\n    /**\n     * @deprecated Use `getPaymasterData` instead\n     */\n    sponsorUserOperation: (\n        args: Omit<\n            PimlicoSponsorUserOperationParameters<entryPointVersion>,\n            \"entryPoint\"\n        >\n    ) => Promise<Prettify<SponsorUserOperationReturnType<entryPointVersion>>>\n    validateSponsorshipPolicies: (\n        args: Prettify<\n            Omit<ValidateSponsorshipPoliciesParameters, \"entryPointAddress\">\n        >\n    ) => Promise<Prettify<ValidateSponsorshipPolicies>[]>\n    getTokenQuotes: <\n        TChainOverride extends Chain | undefined = Chain | undefined\n    >(\n        args: Prettify<\n            Omit<\n                GetTokenQuotesParameters<TChain, TChainOverride>,\n                \"entryPointAddress\"\n            >\n        >\n    ) => Promise<Prettify<GetTokenQuotesReturnType>>\n}\n\nexport const pimlicoActions =\n    <entryPointVersion extends \"0.6\" | \"0.7\">({\n        entryPoint\n    }: {\n        entryPoint: { address: Address; version: entryPointVersion }\n    }) =>\n    <\n        TTransport extends Transport,\n        TChain extends Chain | undefined = Chain | undefined\n    >(\n        client: Client<TTransport, TChain>\n    ): PimlicoActions<TChain, entryPointVersion> => ({\n        getUserOperationGasPrice: async () => getUserOperationGasPrice(client),\n        getUserOperationStatus: async (\n            args: GetUserOperationStatusParameters\n        ) => getUserOperationStatus(client, args),\n        sendCompressedUserOperation: async (args) =>\n            sendCompressedUserOperation(client, {\n                ...args,\n                entryPointAddress: entryPoint.address\n            }),\n        sponsorUserOperation: async (args) =>\n            sponsorUserOperation(client, {\n                ...args,\n                entryPoint\n            }),\n        validateSponsorshipPolicies: async (args) =>\n            validateSponsorshipPolicies(client, {\n                ...args,\n                entryPointAddress: entryPoint.address\n            }),\n        getTokenQuotes: async (args) =>\n            getTokenQuotes(client, {\n                ...args,\n                chain: args.chain,\n                entryPointAddress: entryPoint.address\n            })\n    })\n"],"names":[],"mappings":";;;AAWA,OAAO,EAEH,wBAAwB,EAC3B,MAAM,mDAAmD,CAAA;AAC1D,OAAO,EAGH,sBAAsB,EACzB,MAAM,iDAAiD,CAAA;;AACxD,OAAO,EAGH,oBAAoB,EACvB,MAAM,+CAA+C,CAAA;;AAvBtD,OAAO,EAMH,cAAc,EACd,2BAA2B,EAC3B,2BAA2B,EAC9B,MAAM,0BAA0B,CAAA;;;;;AAwH1B,MAAM,cAAc,GACvB,CAA0C,EACtC,UAAU,EAGb,EAAE,CACH,CADK,AAKD,MAAkC,EACO,CAAG,CAAD,AAAE;YAC7C,wBAAwB,EAAE,KAAK,IAAI,EAAE,+LAAC,2BAAA,AAAwB,EAAC,MAAM,CAAC;YACtE,sBAAsB,EAAE,KAAK,EACzB,IAAsC,EACxC,CAAG,CAAD,sNAAuB,AAAtB,EAAuB,MAAM,EAAE,IAAI,CAAC;YACzC,2BAA2B,EAAE,KAAK,EAAE,IAAI,EAAE,EAAE,kMACxC,8BAAA,AAA2B,EAAC,MAAM,EAAE;oBAChC,GAAG,IAAI;oBACP,iBAAiB,EAAE,UAAU,CAAC,OAAO;iBACxC,CAAC;YACN,oBAAoB,EAAE,KAAK,EAAE,IAAI,EAAE,EAAE,AACjC,kNAAA,AAAoB,EAAC,MAAM,EAAE;oBACzB,GAAG,IAAI;oBACP,UAAU;iBACb,CAAC;YACN,2BAA2B,EAAE,KAAK,EAAE,IAAI,EAAE,EAAE,kMACxC,8BAAA,AAA2B,EAAC,MAAM,EAAE;oBAChC,GAAG,IAAI;oBACP,iBAAiB,EAAE,UAAU,CAAC,OAAO;iBACxC,CAAC;YACN,cAAc,EAAE,KAAK,EAAE,IAAI,EAAE,EAAE,qLAC3B,iBAAA,AAAc,EAAC,MAAM,EAAE;oBACnB,GAAG,IAAI;oBACP,KAAK,EAAE,IAAI,CAAC,KAAK;oBACjB,iBAAiB,EAAE,UAAU,CAAC,OAAO;iBACxC,CAAC;SACT,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 315, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 321, "column": 0}, "map": {"version":3,"file":"pimlico.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/clients/pimlico.ts"],"sourcesContent":["import type {\n    Address,\n    BundlerRpcSchema,\n    Chain,\n    Client,\n    ClientConfig,\n    Prettify,\n    RpcSchema,\n    Transport\n} from \"viem\"\nimport { createClient } from \"viem\"\nimport {\n    type BundlerActions,\n    type PaymasterActions,\n    type SmartAccount,\n    bundlerActions,\n    entryPoint07Address,\n    paymasterActions\n} from \"viem/account-abstraction\"\nimport type { PimlicoRpcSchema } from \"../types/pimlico.js\"\nimport { type PimlicoActions, pimlicoActions } from \"./decorators/pimlico.js\"\n\nexport type PimlicoClient<\n    entryPointVersion extends \"0.6\" | \"0.7\" = \"0.7\" | \"0.6\",\n    transport extends Transport = Transport,\n    chain extends Chain | undefined = Chain | undefined,\n    account extends SmartAccount | undefined = SmartAccount | undefined,\n    client extends Client | undefined = Client | undefined,\n    rpcSchema extends RpcSchema | undefined = undefined\n> = Prettify<\n    Client<\n        transport,\n        chain extends Chain\n            ? chain\n            : // biome-ignore lint/suspicious/noExplicitAny: We need any to infer the chain type\n              client extends Client<any, infer chain>\n              ? chain\n              : undefined,\n        account,\n        rpcSchema extends RpcSchema\n            ? [...BundlerRpcSchema, ...PimlicoRpcSchema, ...rpcSchema]\n            : [...BundlerRpcSchema, ...PimlicoRpcSchema],\n        BundlerActions<account> &\n            PaymasterActions &\n            PimlicoActions<chain, entryPointVersion>\n    >\n>\n\nexport type PimlicoClientConfig<\n    entryPointVersion extends \"0.6\" | \"0.7\" = \"0.7\" | \"0.6\",\n    transport extends Transport = Transport,\n    chain extends Chain | undefined = Chain | undefined,\n    account extends SmartAccount | undefined = SmartAccount | undefined,\n    rpcSchema extends RpcSchema | undefined = undefined\n> = Prettify<\n    Pick<\n        ClientConfig<transport, chain, account, rpcSchema>,\n        | \"account\"\n        | \"cacheTime\"\n        | \"chain\"\n        | \"key\"\n        | \"name\"\n        | \"pollingInterval\"\n        | \"rpcSchema\"\n        | \"transport\"\n    >\n> & {\n    entryPoint?: {\n        address: Address\n        version: entryPointVersion\n    }\n}\n\nexport function createPimlicoClient<\n    entryPointVersion extends \"0.6\" | \"0.7\" = \"0.7\",\n    transport extends Transport = Transport,\n    chain extends Chain | undefined = undefined,\n    account extends SmartAccount | undefined = SmartAccount | undefined,\n    client extends Client | undefined = undefined,\n    rpcSchema extends RpcSchema | undefined = undefined\n>(\n    parameters: PimlicoClientConfig<\n        entryPointVersion,\n        transport,\n        chain,\n        account,\n        rpcSchema\n    >\n): PimlicoClient<\n    entryPointVersion,\n    transport,\n    chain,\n    account,\n    client,\n    rpcSchema\n>\n\nexport function createPimlicoClient(\n    parameters: PimlicoClientConfig\n): PimlicoClient {\n    const {\n        key = \"public\",\n        name = \"Pimlico Bundler Client\",\n        entryPoint\n    } = parameters\n\n    return createClient({\n        ...parameters,\n        key,\n        name,\n        type: \"pimlicoClient\"\n    })\n        .extend(bundlerActions)\n        .extend(paymasterActions)\n        .extend(\n            pimlicoActions({\n                entryPoint: {\n                    address: entryPoint?.address ?? entryPoint07Address,\n                    version: entryPoint?.version ?? \"0.7\"\n                }\n            })\n        )\n}\n"],"names":[],"mappings":";;;AAUA,OAAO,EAAE,YAAY,EAAE,MAAM,MAAM,CAAA;AACnC,OAAO,EAIH,cAAc,EACd,mBAAmB,EACnB,gBAAgB,EACnB,MAAM,0BAA0B,CAAA;;AAEjC,OAAO,EAAuB,cAAc,EAAE,MAAM,yBAAyB,CAAA;;;;;AA6EvE,SAAU,mBAAmB,CAC/B,UAA+B;IAE/B,MAAM,EACF,GAAG,GAAG,QAAQ,EACd,IAAI,GAAG,wBAAwB,EAC/B,UAAU,EACb,GAAG,UAAU,CAAA;IAEd,OAAO,8KAAA,AAAY,EAAC;QAChB,GAAG,UAAU;QACb,GAAG;QACH,IAAI;QACJ,IAAI,EAAE,eAAe;KACxB,CAAC,CACG,MAAM,8LAAC,kBAAc,CAAC,CACtB,MAAM,iMAAC,mBAAgB,CAAC,CACxB,MAAM,mLACH,iBAAA,AAAc,EAAC;QACX,UAAU,EAAE;YACR,OAAO,EAAE,UAAU,EAAE,OAAO,sLAAI,sBAAmB;YACnD,OAAO,EAAE,UAAU,EAAE,OAAO,IAAI,KAAK;SACxC;KACJ,CAAC,CACL,CAAA;AACT,CAAC","ignoreList":[0]}},
    {"offset": {"line": 346, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 352, "column": 0}, "map": {"version":3,"file":"toOwner.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/utils/toOwner.ts"],"sourcesContent":["import {\n    type Account,\n    type Address,\n    type Chain,\n    type EIP1193Provider,\n    type LocalAccount,\n    type OneOf,\n    type Transport,\n    type WalletClient,\n    createWalletClient,\n    custom\n} from \"viem\"\nimport { toAccount } from \"viem/accounts\"\n\nimport { signTypedData } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\n\nexport type EthereumProvider = OneOf<\n    { request(...args: any): Promise<any> } | EIP1193Provider\n>\n\nexport async function toOwner<provider extends EthereumProvider>({\n    owner,\n    address\n}: {\n    owner: OneOf<\n        | provider\n        | WalletClient<Transport, Chain | undefined, Account>\n        | LocalAccount\n    >\n    address?: Address\n}): Promise<LocalAccount> {\n    if (\"type\" in owner && owner.type === \"local\") {\n        return owner as LocalAccount\n    }\n\n    let walletClient:\n        | WalletClient<Transport, Chain | undefined, Account>\n        | undefined = undefined\n\n    if (\"request\" in owner) {\n        if (!address) {\n            try {\n                ;[address] = await (owner as EthereumProvider).request({\n                    method: \"eth_requestAccounts\"\n                })\n            } catch {\n                ;[address] = await (owner as EthereumProvider).request({\n                    method: \"eth_accounts\"\n                })\n            }\n        }\n        if (!address) {\n            // For TS to be happy\n            throw new Error(\"address is required\")\n        }\n        walletClient = createWalletClient({\n            account: address,\n            transport: custom(owner as EthereumProvider)\n        })\n    }\n\n    if (!walletClient) {\n        walletClient = owner as WalletClient<\n            Transport,\n            Chain | undefined,\n            Account\n        >\n    }\n\n    return toAccount({\n        address: walletClient.account.address,\n        async signMessage({ message }) {\n            return walletClient.signMessage({ message })\n        },\n        async signTypedData(typedData) {\n            return getAction(\n                walletClient,\n                signTypedData,\n                \"signTypedData\"\n            )(typedData as any)\n        },\n        async signTransaction(_) {\n            throw new Error(\n                \"Smart account signer doesn't need to sign transactions\"\n            )\n        }\n    })\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EASH,kBAAkB,EAClB,MAAM,EACT,MAAM,MAAM,CAAA;;AACb,OAAO,EAAE,SAAS,EAAE,MAAM,eAAe,CAAA;AAGzC,OAAO,EAAE,SAAS,EAAE,MAAM,YAAY,CAAA;AADtC,OAAO,EAAE,aAAa,EAAE,MAAM,cAAc,CAAA;;;;;AAOrC,KAAK,UAAU,OAAO,CAAoC,EAC7D,KAAK,EACL,OAAO,EAQV;IACG,IAAI,MAAM,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;QAC5C,OAAO,KAAqB,CAAA;IAChC,CAAC;IAED,IAAI,YAAY,GAEE,SAAS,CAAA;IAE3B,IAAI,SAAS,IAAI,KAAK,EAAE,CAAC;QACrB,IAAI,CAAC,OAAO,EAAE,CAAC;YACX,IAAI,CAAC;;gBACA,CAAC,OAAO,CAAC,GAAG,MAAO,KAA0B,CAAC,OAAO,CAAC;oBACnD,MAAM,EAAE,qBAAqB;iBAChC,CAAC,CAAA;YACN,CAAC,CAAC,OAAM,CAAC;;gBACJ,CAAC,OAAO,CAAC,GAAG,MAAO,KAA0B,CAAC,OAAO,CAAC;oBACnD,MAAM,EAAE,cAAc;iBACzB,CAAC,CAAA;YACN,CAAC;QACL,CAAC;QACD,IAAI,CAAC,OAAO,EAAE,CAAC;YACX,qBAAqB;YACrB,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAA;QAC1C,CAAC;QACD,YAAY,wKAAG,qBAAA,AAAkB,EAAC;YAC9B,OAAO,EAAE,OAAO;YAChB,SAAS,EAAE,gLAAA,AAAM,EAAC,KAAyB,CAAC;SAC/C,CAAC,CAAA;IACN,CAAC;IAED,IAAI,CAAC,YAAY,EAAE,CAAC;QAChB,YAAY,GAAG,KAId,CAAA;IACL,CAAC;IAED,QAAO,wKAAA,AAAS,EAAC;QACb,OAAO,EAAE,YAAY,CAAC,OAAO,CAAC,OAAO;QACrC,KAAK,CAAC,WAAW,EAAC,EAAE,OAAO,EAAE;YACzB,OAAO,YAAY,CAAC,WAAW,CAAC;gBAAE,OAAO;YAAA,CAAE,CAAC,CAAA;QAChD,CAAC;QACD,KAAK,CAAC,aAAa,EAAC,SAAS;YACzB,iKAAO,YAAA,AAAS,EACZ,YAAY,wKACZ,gBAAa,EACb,eAAe,CAClB,CAAC,SAAgB,CAAC,CAAA;QACvB,CAAC;QACD,KAAK,CAAC,eAAe,EAAC,CAAC;YACnB,MAAM,IAAI,KAAK,CACX,wDAAwD,CAC3D,CAAA;QACL,CAAC;KACJ,CAAC,CAAA;AACN,CAAC","ignoreList":[0]}},
    {"offset": {"line": 410, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 416, "column": 0}, "map": {"version":3,"file":"isSmartAccountDeployed.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/utils/isSmartAccountDeployed.ts"],"sourcesContent":["import type { Address, Client } from \"viem\"\nimport { getCode } from \"viem/actions\"\n\nexport const isSmartAccountDeployed = async (\n    client: Client,\n    address: Address\n): Promise<boolean> => {\n    const contractCode = await getCode(client, {\n        address: address\n    })\n\n    return Boolean(contractCode)\n}\n"],"names":[],"mappings":";;;AACA,OAAO,EAAE,OAAO,EAAE,MAAM,cAAc,CAAA;;AAE/B,MAAM,sBAAsB,GAAG,KAAK,EACvC,MAAc,EACd,OAAgB,EACA,EAAE;IAClB,MAAM,YAAY,GAAG,0KAAM,UAAA,AAAO,EAAC,MAAM,EAAE;QACvC,OAAO,EAAE,OAAO;KACnB,CAAC,CAAA;IAEF,OAAO,OAAO,CAAC,YAAY,CAAC,CAAA;AAChC,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 427, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 433, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/errors/index.ts"],"sourcesContent":["import { BaseError } from \"viem\"\n\nexport class AccountNotFoundError extends BaseError {\n    constructor({ docsPath }: { docsPath?: string | undefined } = {}) {\n        super(\n            [\n                \"Could not find an Account to execute with this Action.\",\n                \"Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client.\"\n            ].join(\"\\n\"),\n            {\n                docsPath,\n                docsSlug: \"account\",\n                name: \"AccountNotFoundError\"\n            }\n        )\n    }\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,MAAM,CAAA;;AAE1B,MAAO,oBAAqB,2JAAQ,YAAS;IAC/C,YAAY,EAAE,QAAQ,EAAA,GAAwC,CAAA,CAAE,CAAA;QAC5D,KAAK,CACD;YACI,wDAAwD;YACxD,kHAAkH;SACrH,CAAC,IAAI,CAAC,IAAI,CAAC,EACZ;YACI,QAAQ;YACR,QAAQ,EAAE,SAAS;YACnB,IAAI,EAAE,sBAAsB;SAC/B,CACJ,CAAA;IACL,CAAC;CACJ","ignoreList":[0]}},
    {"offset": {"line": 450, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 456, "column": 0}, "map": {"version":3,"file":"supportsExecutionMode.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/actions/erc7579/supportsExecutionMode.ts"],"sourcesContent":["import {\n    type Chain,\n    type Client,\n    ContractFunctionExecutionError,\n    type Hex,\n    type Transport,\n    decodeFunctionResult,\n    encodeFunctionData,\n    encodePacked,\n    toBytes,\n    toHex\n} from \"viem\"\nimport type {\n    GetSmartAccountParameter,\n    SmartAccount\n} from \"viem/account-abstraction\"\nimport { call, readContract } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\nimport { parseAccount } from \"viem/utils\"\nimport { AccountNotFoundError } from \"../../errors/index.js\"\n\nexport type CallType = \"call\" | \"delegatecall\" | \"batchcall\"\n\nexport type ExecutionMode<callType extends CallType> = {\n    type: callType\n    revertOnError?: boolean\n    selector?: Hex\n    context?: Hex\n}\n\nexport type SupportsExecutionModeParameters<\n    TSmartAccount extends SmartAccount | undefined,\n    callType extends CallType = CallType\n> = GetSmartAccountParameter<TSmartAccount> & ExecutionMode<callType>\n\nfunction parseCallType(callType: CallType) {\n    switch (callType) {\n        case \"call\":\n            return \"0x00\"\n        case \"batchcall\":\n            return \"0x01\"\n        case \"delegatecall\":\n            return \"0xff\"\n    }\n}\n\nexport function encodeExecutionMode<callType extends CallType>({\n    type,\n    revertOnError,\n    selector,\n    context\n}: ExecutionMode<callType>): Hex {\n    return encodePacked(\n        [\"bytes1\", \"bytes1\", \"bytes4\", \"bytes4\", \"bytes22\"],\n        [\n            toHex(toBytes(parseCallType(type), { size: 1 })),\n            toHex(toBytes(revertOnError ? \"0x01\" : \"0x00\", { size: 1 })),\n            toHex(toBytes(\"0x0\", { size: 4 })),\n            toHex(toBytes(selector ?? \"0x\", { size: 4 })),\n            toHex(toBytes(context ?? \"0x\", { size: 22 }))\n        ]\n    )\n}\n\nexport async function supportsExecutionMode<\n    TSmartAccount extends SmartAccount | undefined,\n    callType extends CallType = CallType\n>(\n    client: Client<Transport, Chain | undefined, TSmartAccount>,\n    args: SupportsExecutionModeParameters<TSmartAccount, callType>\n): Promise<boolean> {\n    const {\n        account: account_ = client.account,\n        type,\n        revertOnError,\n        selector,\n        context\n    } = args\n\n    if (!account_) {\n        throw new AccountNotFoundError({\n            docsPath: \"/docs/actions/wallet/sendTransaction\"\n        })\n    }\n\n    const account = parseAccount(account_) as SmartAccount\n\n    const publicClient = account.client\n\n    const encodedMode = encodeExecutionMode({\n        type,\n        revertOnError,\n        selector,\n        context\n    })\n\n    const abi = [\n        {\n            name: \"supportsExecutionMode\",\n            type: \"function\",\n            stateMutability: \"view\",\n            inputs: [\n                {\n                    type: \"bytes32\",\n                    name: \"encodedMode\"\n                }\n            ],\n            outputs: [\n                {\n                    type: \"bool\"\n                }\n            ]\n        }\n    ] as const\n\n    try {\n        return await getAction(\n            publicClient,\n            readContract,\n            \"readContract\"\n        )({\n            abi,\n            functionName: \"supportsExecutionMode\",\n            args: [encodedMode],\n            address: account.address\n        })\n    } catch (error) {\n        if (error instanceof ContractFunctionExecutionError) {\n            const { factory, factoryData } = await account.getFactoryArgs()\n\n            const result = await getAction(\n                publicClient,\n                call,\n                \"call\"\n            )({\n                factory: factory,\n                factoryData: factoryData,\n                to: account.address,\n                data: encodeFunctionData({\n                    abi,\n                    functionName: \"supportsExecutionMode\",\n                    args: [encodedMode]\n                })\n            })\n\n            if (!result || !result.data) {\n                throw new Error(\"accountId result is empty\")\n            }\n\n            return decodeFunctionResult({\n                abi,\n                functionName: \"supportsExecutionMode\",\n                data: result.data\n            })\n        }\n\n        throw error\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 580, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 586, "column": 0}, "map": {"version":3,"file":"encode7579Calls.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/utils/encode7579Calls.ts"],"sourcesContent":["import {\n    type Address,\n    type Hex,\n    concatHex,\n    encodeAbiParameters,\n    encodeFunctionData,\n    toHex\n} from \"viem\"\nimport {\n    type CallType,\n    type ExecutionMode,\n    encodeExecutionMode\n} from \"../actions/erc7579/supportsExecutionMode.js\"\n\nexport type EncodeCallDataParams<callType extends CallType> = {\n    mode: ExecutionMode<callType>\n    callData: readonly {\n        to: Address\n        value?: bigint | undefined\n        data?: Hex | undefined\n    }[]\n}\n\nexport function encode7579Calls<callType extends CallType>({\n    mode,\n    callData\n}: EncodeCallDataParams<callType>): Hex {\n    if (callData.length > 1 && mode?.type !== \"batchcall\") {\n        throw new Error(\n            `mode ${JSON.stringify(mode)} does not supported for batchcall calldata`\n        )\n    }\n\n    const executeAbi = [\n        {\n            type: \"function\",\n            name: \"execute\",\n            inputs: [\n                {\n                    name: \"execMode\",\n                    type: \"bytes32\",\n                    internalType: \"ExecMode\"\n                },\n                {\n                    name: \"executionCalldata\",\n                    type: \"bytes\",\n                    internalType: \"bytes\"\n                }\n            ],\n            outputs: [],\n            stateMutability: \"payable\"\n        }\n    ] as const\n\n    if (callData.length > 1) {\n        return encodeFunctionData({\n            abi: executeAbi,\n            functionName: \"execute\",\n            args: [\n                encodeExecutionMode(mode),\n                encodeAbiParameters(\n                    [\n                        {\n                            name: \"executionBatch\",\n                            type: \"tuple[]\",\n                            components: [\n                                {\n                                    name: \"target\",\n                                    type: \"address\"\n                                },\n                                {\n                                    name: \"value\",\n                                    type: \"uint256\"\n                                },\n                                {\n                                    name: \"callData\",\n                                    type: \"bytes\"\n                                }\n                            ]\n                        }\n                    ],\n                    [\n                        callData.map((arg) => {\n                            return {\n                                target: arg.to,\n                                value: arg.value ?? 0n,\n                                callData: arg.data ?? \"0x\"\n                            }\n                        })\n                    ]\n                )\n            ]\n        })\n    }\n\n    const call = callData.length === 0 ? undefined : callData[0]\n\n    if (!call) {\n        throw new Error(\"No calls to encode\")\n    }\n\n    return encodeFunctionData({\n        abi: executeAbi,\n        functionName: \"execute\",\n        args: [\n            encodeExecutionMode(mode),\n            concatHex([\n                call.to,\n                toHex(call.value ?? 0n, { size: 32 }),\n                call.data ?? \"0x\"\n            ])\n        ]\n    })\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAGH,SAAS,EACT,mBAAmB,EACnB,kBAAkB,EAClB,KAAK,EACR,MAAM,MAAM,CAAA;AACb,OAAO,EAGH,mBAAmB,EACtB,MAAM,6CAA6C,CAAA;;;;;;AAW9C,SAAU,eAAe,CAA4B,EACvD,IAAI,EACJ,QAAQ,EACqB;IAC7B,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,EAAE,IAAI,KAAK,WAAW,EAAE,CAAC;QACpD,MAAM,IAAI,KAAK,CACX,CAAA,KAAA,EAAQ,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAA,0CAAA,CAA4C,CAC3E,CAAA;IACL,CAAC;IAED,MAAM,UAAU,GAAG;QACf;YACI,IAAI,EAAE,UAAU;YAChB,IAAI,EAAE,SAAS;YACf,MAAM,EAAE;gBACJ;oBACI,IAAI,EAAE,UAAU;oBAChB,IAAI,EAAE,SAAS;oBACf,YAAY,EAAE,UAAU;iBAC3B;gBACD;oBACI,IAAI,EAAE,mBAAmB;oBACzB,IAAI,EAAE,OAAO;oBACb,YAAY,EAAE,OAAO;iBACxB;aACJ;YACD,OAAO,EAAE,EAAE;YACX,eAAe,EAAE,SAAS;SAC7B;KACK,CAAA;IAEV,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QACtB,iLAAO,qBAAA,AAAkB,EAAC;YACtB,GAAG,EAAE,UAAU;YACf,YAAY,EAAE,SAAS;YACvB,IAAI,EAAE;6MACF,sBAAA,AAAmB,EAAC,IAAI,CAAC;iBACzB,gMAAA,AAAmB,EACf;oBACI;wBACI,IAAI,EAAE,gBAAgB;wBACtB,IAAI,EAAE,SAAS;wBACf,UAAU,EAAE;4BACR;gCACI,IAAI,EAAE,QAAQ;gCACd,IAAI,EAAE,SAAS;6BAClB;4BACD;gCACI,IAAI,EAAE,OAAO;gCACb,IAAI,EAAE,SAAS;6BAClB;4BACD;gCACI,IAAI,EAAE,UAAU;gCAChB,IAAI,EAAE,OAAO;6BAChB;yBACJ;qBACJ;iBACJ,EACD;oBACI,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE;wBACjB,OAAO;4BACH,MAAM,EAAE,GAAG,CAAC,EAAE;4BACd,KAAK,EAAE,GAAG,CAAC,KAAK,IAAI,EAAE;4BACtB,QAAQ,EAAE,GAAG,CAAC,IAAI,IAAI,IAAI;yBAC7B,CAAA;oBACL,CAAC,CAAC;iBACL,CACJ;aACJ;SACJ,CAAC,CAAA;IACN,CAAC;IAED,MAAM,IAAI,GAAG,QAAQ,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAA;IAE5D,IAAI,CAAC,IAAI,EAAE,CAAC;QACR,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAA;IACzC,CAAC;IAED,QAAO,8LAAA,AAAkB,EAAC;QACtB,GAAG,EAAE,UAAU;QACf,YAAY,EAAE,SAAS;QACvB,IAAI,EAAE;yMACF,sBAAA,AAAmB,EAAC,IAAI,CAAC;2KACzB,YAAA,AAAS,EAAC;gBACN,IAAI,CAAC,EAAE;kLACP,QAAA,AAAK,EAAC,IAAI,CAAC,KAAK,IAAI,EAAE,EAAE;oBAAE,IAAI,EAAE,EAAE;gBAAA,CAAE,CAAC;gBACrC,IAAI,CAAC,IAAI,IAAI,IAAI;aACpB,CAAC;SACL;KACJ,CAAC,CAAA;AACN,CAAC","ignoreList":[0]}},
    {"offset": {"line": 676, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 682, "column": 0}, "map": {"version":3,"file":"decode7579Calls.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/utils/decode7579Calls.ts"],"sourcesContent":["import {\n    type Address,\n    type Hex,\n    decodeAbiParameters,\n    decodeFunctionData,\n    getAddress,\n    size,\n    slice\n} from \"viem\"\nimport type {\n    CallType,\n    ExecutionMode\n} from \"../actions/erc7579/supportsExecutionMode.js\"\n\nexport type DecodeCallDataReturnType = {\n    mode: ExecutionMode<CallType>\n    callData: readonly {\n        to: Address\n        value?: bigint | undefined\n        data?: Hex | undefined\n    }[]\n}\n\nexport function decode7579Calls(callData: Hex): DecodeCallDataReturnType {\n    const executeAbi = [\n        {\n            type: \"function\",\n            name: \"execute\",\n            inputs: [\n                {\n                    name: \"execMode\",\n                    type: \"bytes32\",\n                    internalType: \"ExecMode\"\n                },\n                {\n                    name: \"executionCalldata\",\n                    type: \"bytes\",\n                    internalType: \"bytes\"\n                }\n            ],\n            outputs: [],\n            stateMutability: \"payable\"\n        }\n    ] as const\n\n    const decoded = decodeFunctionData({\n        abi: executeAbi,\n        data: callData\n    })\n\n    const mode = decoded.args[0]\n    const executionCalldata = decoded.args[1]\n\n    const callType = slice(mode, 0, 1) // First byte\n    const revertOnError = slice(mode, 1, 2) // Second byte\n    const selector = slice(mode, 3, 7) as Hex // bytes 5-8\n    const context = slice(mode, 7) as Hex // bytes 9-32\n\n    let type: CallType\n    switch (BigInt(callType)) {\n        case BigInt(0x00):\n            type = \"call\"\n            break\n        case BigInt(0x01):\n            type = \"batchcall\"\n            break\n        case BigInt(0xff):\n            type = \"delegatecall\"\n            break\n        default:\n            throw new Error(\"Invalid call type\")\n    }\n\n    const decodedMode: ExecutionMode<CallType> = {\n        type,\n        revertOnError: BigInt(revertOnError) === BigInt(1),\n        selector,\n        context\n    }\n\n    if (decodedMode.type === \"batchcall\") {\n        const [calls] = decodeAbiParameters(\n            [\n                {\n                    name: \"executionBatch\",\n                    type: \"tuple[]\",\n                    components: [\n                        {\n                            name: \"target\",\n                            type: \"address\"\n                        },\n                        {\n                            name: \"value\",\n                            type: \"uint256\"\n                        },\n                        {\n                            name: \"callData\",\n                            type: \"bytes\"\n                        }\n                    ]\n                }\n            ],\n            executionCalldata\n        )\n\n        return {\n            mode: decodedMode,\n            callData: calls.map((call) => ({\n                to: call.target,\n                value: call.value,\n                data: call.callData\n            }))\n        }\n    }\n\n    // Single call - calldata is encoded as concatenated (to, value, data)\n    const to = getAddress(slice(executionCalldata, 0, 20)) // 20 bytes address with 0x prefix\n    const value = BigInt(slice(executionCalldata, 20, 52)) // 32 bytes value\n\n    const data =\n        size(executionCalldata) > 52 ? slice(executionCalldata, 52) : \"0x\" // Remaining bytes are calldata\n\n    return {\n        mode: decodedMode,\n        callData: [\n            {\n                to,\n                value,\n                data\n            }\n        ]\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 787, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 793, "column": 0}, "map": {"version":3,"file":"getAccountNonce.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/actions/public/getAccountNonce.ts"],"sourcesContent":["import type { Address, Client } from \"viem\"\nimport { readContract } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\n\nexport type GetAccountNonceParams = {\n    address: Address\n    entryPointAddress: Address\n    key?: bigint\n}\n\n/**\n * Returns the nonce of the account with the entry point.\n *\n * - Docs: https://docs.pimlico.io/permissionless/reference/public-actions/getAccountNonce\n *\n * @param client {@link client} that you created using viem's createPublicClient.\n * @param args {@link GetAccountNonceParams} address, entryPoint & key\n * @returns bigint nonce\n *\n * @example\n * import { createPublicClient } from \"viem\"\n * import { getAccountNonce } from \"permissionless/actions\"\n *\n * const client = createPublicClient({\n *      chain: goerli,\n *      transport: http(\"https://goerli.infura.io/v3/your-infura-key\")\n * })\n *\n * const nonce = await getAccountNonce(client, {\n *      address,\n *      entryPoint,\n *      key\n * })\n *\n * // Return 0n\n */\nexport const getAccountNonce = async (\n    client: Client,\n    args: GetAccountNonceParams\n): Promise<bigint> => {\n    const { address, entryPointAddress, key = BigInt(0) } = args\n\n    return await getAction(\n        client,\n        readContract,\n        \"readContract\"\n    )({\n        address: entryPointAddress,\n        abi: [\n            {\n                inputs: [\n                    {\n                        name: \"sender\",\n                        type: \"address\"\n                    },\n                    {\n                        name: \"key\",\n                        type: \"uint192\"\n                    }\n                ],\n                name: \"getNonce\",\n                outputs: [\n                    {\n                        name: \"nonce\",\n                        type: \"uint256\"\n                    }\n                ],\n                stateMutability: \"view\",\n                type: \"function\"\n            }\n        ],\n        functionName: \"getNonce\",\n        args: [address, key]\n    })\n}\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,SAAS,EAAE,MAAM,YAAY,CAAA;AADtC,OAAO,EAAE,YAAY,EAAE,MAAM,cAAc,CAAA;;;AAmCpC,MAAM,eAAe,GAAG,KAAK,EAChC,MAAc,EACd,IAA2B,EACZ,EAAE;IACjB,MAAM,EAAE,OAAO,EAAE,iBAAiB,EAAE,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,EAAE,GAAG,IAAI,CAAA;IAE5D,OAAO,OAAM,qKAAA,AAAS,EAClB,MAAM,uKACN,eAAY,EACZ,cAAc,CACjB,CAAC;QACE,OAAO,EAAE,iBAAiB;QAC1B,GAAG,EAAE;YACD;gBACI,MAAM,EAAE;oBACJ;wBACI,IAAI,EAAE,QAAQ;wBACd,IAAI,EAAE,SAAS;qBAClB;oBACD;wBACI,IAAI,EAAE,KAAK;wBACX,IAAI,EAAE,SAAS;qBAClB;iBACJ;gBACD,IAAI,EAAE,UAAU;gBAChB,OAAO,EAAE;oBACL;wBACI,IAAI,EAAE,OAAO;wBACb,IAAI,EAAE,SAAS;qBAClB;iBACJ;gBACD,eAAe,EAAE,MAAM;gBACvB,IAAI,EAAE,UAAU;aACnB;SACJ;QACD,YAAY,EAAE,UAAU;QACxB,IAAI,EAAE;YAAC,OAAO;YAAE,GAAG;SAAC;KACvB,CAAC,CAAA;AACN,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 834, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 840, "column": 0}, "map": {"version":3,"file":"signUserOperation.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/accounts/safe/signUserOperation.ts"],"sourcesContent":["import {\n    type Account,\n    type Address,\n    type Chain,\n    type Hex,\n    type LocalAccount,\n    type OneOf,\n    type Transport,\n    type UnionPartialBy,\n    type WalletClient,\n    concat,\n    concatHex,\n    decodeAbiParameters,\n    encodeAbiParameters,\n    encodePacked\n} from \"viem\"\nimport type { UserOperation } from \"viem/account-abstraction\"\nimport { toOwner } from \"../../utils/index.js\"\nimport type { EthereumProvider } from \"../../utils/toOwner.js\"\nimport {\n    EIP712_SAFE_OPERATION_TYPE_V06,\n    EIP712_SAFE_OPERATION_TYPE_V07,\n    type SafeVersion,\n    getDefaultAddresses,\n    getPaymasterAndData\n} from \"./toSafeSmartAccount.js\"\n\nexport async function signUserOperation(\n    parameters: UnionPartialBy<UserOperation, \"sender\"> & {\n        version: SafeVersion\n        entryPoint: {\n            address: Address\n            version: \"0.6\" | \"0.7\"\n        }\n        owners: Account[]\n        account: OneOf<\n            | EthereumProvider\n            | WalletClient<Transport, Chain | undefined, Account>\n            | LocalAccount\n        >\n        chainId: number\n        signatures?: Hex\n        validAfter?: number\n        validUntil?: number\n        safe4337ModuleAddress?: Address\n    }\n) {\n    const {\n        chainId,\n        entryPoint,\n        validAfter = 0,\n        validUntil = 0,\n        safe4337ModuleAddress: _safe4337ModuleAddress,\n        version,\n        owners,\n        signatures: existingSignatures,\n        account,\n        ...userOperation\n    } = parameters\n\n    const { safe4337ModuleAddress } = getDefaultAddresses(\n        version,\n        entryPoint.version,\n        {\n            safe4337ModuleAddress: _safe4337ModuleAddress\n        }\n    )\n\n    const message = {\n        safe: userOperation.sender,\n        callData: userOperation.callData,\n        nonce: userOperation.nonce,\n        initCode: userOperation.initCode ?? \"0x\",\n        maxFeePerGas: userOperation.maxFeePerGas,\n        maxPriorityFeePerGas: userOperation.maxPriorityFeePerGas,\n        preVerificationGas: userOperation.preVerificationGas,\n        verificationGasLimit: userOperation.verificationGasLimit,\n        callGasLimit: userOperation.callGasLimit,\n        paymasterAndData: userOperation.paymasterAndData ?? \"0x\",\n        validAfter: validAfter,\n        validUntil: validUntil,\n        entryPoint: entryPoint.address\n    }\n\n    if (\"initCode\" in userOperation) {\n        message.paymasterAndData = userOperation.paymasterAndData ?? \"0x\"\n    }\n\n    if (\"factory\" in userOperation) {\n        if (userOperation.factory && userOperation.factoryData) {\n            message.initCode = concatHex([\n                userOperation.factory,\n                userOperation.factoryData\n            ])\n        }\n        if (!userOperation.sender) {\n            throw new Error(\"Sender is required\")\n        }\n        message.paymasterAndData = getPaymasterAndData({\n            ...userOperation,\n            sender: userOperation.sender\n        })\n    }\n\n    const localOwners = [\n        await toOwner({\n            owner: account as OneOf<LocalAccount | EthereumProvider>\n        })\n    ]\n\n    let unPackedSignatures: readonly { signer: Address; data: Hex }[] = []\n\n    if (existingSignatures) {\n        const decoded = decodeAbiParameters(\n            [\n                {\n                    components: [\n                        { type: \"address\", name: \"signer\" },\n                        { type: \"bytes\", name: \"data\" }\n                    ],\n                    name: \"signatures\",\n                    type: \"tuple[]\"\n                }\n            ],\n            existingSignatures\n        )\n\n        unPackedSignatures = decoded[0]\n    }\n\n    const signatures: { signer: Address; data: Hex }[] = [\n        ...unPackedSignatures,\n        ...(await Promise.all(\n            localOwners.map(async (localOwner) => ({\n                signer: localOwner.address,\n                data: await localOwner.signTypedData({\n                    domain: {\n                        chainId,\n                        verifyingContract: safe4337ModuleAddress\n                    },\n                    types:\n                        entryPoint.version === \"0.6\"\n                            ? EIP712_SAFE_OPERATION_TYPE_V06\n                            : EIP712_SAFE_OPERATION_TYPE_V07,\n                    primaryType: \"SafeOp\",\n                    message: message\n                })\n            }))\n        ))\n    ]\n\n    if (signatures.length !== owners.length) {\n        return encodeAbiParameters(\n            [\n                {\n                    components: [\n                        { type: \"address\", name: \"signer\" },\n                        { type: \"bytes\", name: \"data\" }\n                    ],\n                    name: \"signatures\",\n                    type: \"tuple[]\"\n                }\n            ],\n            [signatures]\n        )\n    }\n\n    signatures.sort((left, right) =>\n        left.signer.toLowerCase().localeCompare(right.signer.toLowerCase())\n    )\n    const signatureBytes = concat(signatures.map((sig) => sig.data))\n\n    return encodePacked(\n        [\"uint48\", \"uint48\", \"bytes\"],\n        [validAfter, validUntil, signatureBytes]\n    )\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 962, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 968, "column": 0}, "map": {"version":3,"file":"toSafeSmartAccount.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/accounts/safe/toSafeSmartAccount.ts"],"sourcesContent":["import {\n    type Account,\n    type Address,\n    type Assign,\n    type Chain,\n    type Client,\n    type Hex,\n    type LocalAccount,\n    type OneOf,\n    type SignableMessage,\n    type Transport,\n    type TypedData,\n    type TypedDataDefinition,\n    type WalletClient,\n    concat,\n    decodeFunctionData,\n    encodeAbiParameters,\n    encodeFunctionData,\n    encodePacked,\n    getAddress,\n    getContractAddress,\n    hashMessage,\n    hashTypedData,\n    hexToBigInt,\n    keccak256,\n    pad,\n    size,\n    slice,\n    toBytes,\n    toHex,\n    zeroAddress\n} from \"viem\"\nimport {\n    type SmartAccount,\n    type SmartAccountImplementation,\n    type UserOperation,\n    entryPoint06Abi,\n    entryPoint07Abi,\n    entryPoint07Address,\n    toSmartAccount\n} from \"viem/account-abstraction\"\nimport { getChainId, readContract } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\nimport { getAccountNonce } from \"../../actions/public/getAccountNonce.js\"\nimport { decode7579Calls } from \"../../utils/decode7579Calls.js\"\nimport { encode7579Calls } from \"../../utils/encode7579Calls.js\"\nimport { isSmartAccountDeployed } from \"../../utils/isSmartAccountDeployed.js\"\nimport { type EthereumProvider, toOwner } from \"../../utils/toOwner.js\"\nimport { signUserOperation } from \"./signUserOperation.js\"\n\nexport type SafeVersion = \"1.4.1\"\n\nconst multiSendAbi = [\n    {\n        inputs: [\n            {\n                internalType: \"bytes\",\n                name: \"transactions\",\n                type: \"bytes\"\n            }\n        ],\n        name: \"multiSend\",\n        outputs: [],\n        stateMutability: \"payable\",\n        type: \"function\"\n    }\n] as const\n\nconst initSafe7579Abi = [\n    {\n        type: \"function\",\n        name: \"initSafe7579\",\n        inputs: [\n            {\n                name: \"safe7579\",\n                type: \"address\",\n                internalType: \"address\"\n            },\n            {\n                name: \"executors\",\n                type: \"tuple[]\",\n                internalType: \"struct ModuleInit[]\",\n                components: [\n                    {\n                        name: \"module\",\n                        type: \"address\",\n                        internalType: \"address\"\n                    },\n                    {\n                        name: \"initData\",\n                        type: \"bytes\",\n                        internalType: \"bytes\"\n                    }\n                ]\n            },\n            {\n                name: \"fallbacks\",\n                type: \"tuple[]\",\n                internalType: \"struct ModuleInit[]\",\n                components: [\n                    {\n                        name: \"module\",\n                        type: \"address\",\n                        internalType: \"address\"\n                    },\n                    {\n                        name: \"initData\",\n                        type: \"bytes\",\n                        internalType: \"bytes\"\n                    }\n                ]\n            },\n            {\n                name: \"hooks\",\n                type: \"tuple[]\",\n                internalType: \"struct ModuleInit[]\",\n                components: [\n                    {\n                        name: \"module\",\n                        type: \"address\",\n                        internalType: \"address\"\n                    },\n                    {\n                        name: \"initData\",\n                        type: \"bytes\",\n                        internalType: \"bytes\"\n                    }\n                ]\n            },\n            {\n                name: \"attesters\",\n                type: \"address[]\",\n                internalType: \"address[]\"\n            },\n            {\n                name: \"threshold\",\n                type: \"uint8\",\n                internalType: \"uint8\"\n            }\n        ],\n        outputs: [],\n        stateMutability: \"nonpayable\"\n    }\n] as const\n\nconst preValidationSetupAbi = [\n    {\n        type: \"function\",\n        name: \"preValidationSetup\",\n        inputs: [\n            {\n                name: \"initHash\",\n                type: \"bytes32\",\n                internalType: \"bytes32\"\n            },\n            {\n                name: \"to\",\n                type: \"address\",\n                internalType: \"address\"\n            },\n            {\n                name: \"preInit\",\n                type: \"bytes\",\n                internalType: \"bytes\"\n            }\n        ],\n        outputs: [],\n        stateMutability: \"nonpayable\"\n    }\n] as const\n\nconst enableModulesAbi = [\n    {\n        inputs: [\n            {\n                internalType: \"address[]\",\n                name: \"modules\",\n                type: \"address[]\"\n            }\n        ],\n        name: \"enableModules\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\"\n    }\n] as const\n\nconst setupAbi = [\n    {\n        inputs: [\n            {\n                internalType: \"address[]\",\n                name: \"_owners\",\n                type: \"address[]\"\n            },\n            {\n                internalType: \"uint256\",\n                name: \"_threshold\",\n                type: \"uint256\"\n            },\n            {\n                internalType: \"address\",\n                name: \"to\",\n                type: \"address\"\n            },\n            {\n                internalType: \"bytes\",\n                name: \"data\",\n                type: \"bytes\"\n            },\n            {\n                internalType: \"address\",\n                name: \"fallbackHandler\",\n                type: \"address\"\n            },\n            {\n                internalType: \"address\",\n                name: \"paymentToken\",\n                type: \"address\"\n            },\n            {\n                internalType: \"uint256\",\n                name: \"payment\",\n                type: \"uint256\"\n            },\n            {\n                internalType: \"address payable\",\n                name: \"paymentReceiver\",\n                type: \"address\"\n            }\n        ],\n        name: \"setup\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\"\n    }\n] as const\n\nconst createProxyWithNonceAbi = [\n    {\n        inputs: [\n            {\n                internalType: \"address\",\n                name: \"_singleton\",\n                type: \"address\"\n            },\n            {\n                internalType: \"bytes\",\n                name: \"initializer\",\n                type: \"bytes\"\n            },\n            {\n                internalType: \"uint256\",\n                name: \"saltNonce\",\n                type: \"uint256\"\n            }\n        ],\n        name: \"createProxyWithNonce\",\n        outputs: [\n            {\n                internalType: \"contract SafeProxy\",\n                name: \"proxy\",\n                type: \"address\"\n            }\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"function\"\n    }\n] as const\n\nconst setupSafeAbi = [\n    {\n        type: \"function\",\n        name: \"setupSafe\",\n        inputs: [\n            {\n                name: \"initData\",\n                type: \"tuple\",\n                internalType: \"struct Safe7579Launchpad.InitData\",\n                components: [\n                    {\n                        name: \"singleton\",\n                        type: \"address\",\n                        internalType: \"address\"\n                    },\n                    {\n                        name: \"owners\",\n                        type: \"address[]\",\n                        internalType: \"address[]\"\n                    },\n                    {\n                        name: \"threshold\",\n                        type: \"uint256\",\n                        internalType: \"uint256\"\n                    },\n                    {\n                        name: \"setupTo\",\n                        type: \"address\",\n                        internalType: \"address\"\n                    },\n                    {\n                        name: \"setupData\",\n                        type: \"bytes\",\n                        internalType: \"bytes\"\n                    },\n                    {\n                        name: \"safe7579\",\n                        type: \"address\",\n                        internalType: \"contract ISafe7579\"\n                    },\n                    {\n                        name: \"validators\",\n                        type: \"tuple[]\",\n                        internalType: \"struct ModuleInit[]\",\n                        components: [\n                            {\n                                name: \"module\",\n                                type: \"address\",\n                                internalType: \"address\"\n                            },\n                            {\n                                name: \"initData\",\n                                type: \"bytes\",\n                                internalType: \"bytes\"\n                            }\n                        ]\n                    },\n                    {\n                        name: \"callData\",\n                        type: \"bytes\",\n                        internalType: \"bytes\"\n                    }\n                ]\n            }\n        ],\n        outputs: [],\n        stateMutability: \"nonpayable\"\n    }\n] as const\n\nconst executeUserOpWithErrorStringAbi = [\n    {\n        inputs: [\n            {\n                internalType: \"address\",\n                name: \"to\",\n                type: \"address\"\n            },\n            {\n                internalType: \"uint256\",\n                name: \"value\",\n                type: \"uint256\"\n            },\n            {\n                internalType: \"bytes\",\n                name: \"data\",\n                type: \"bytes\"\n            },\n            {\n                internalType: \"uint8\",\n                name: \"operation\",\n                type: \"uint8\"\n            }\n        ],\n        name: \"executeUserOpWithErrorString\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\"\n    }\n] as const\n\nexport const EIP712_SAFE_OPERATION_TYPE_V06 = {\n    SafeOp: [\n        { type: \"address\", name: \"safe\" },\n        { type: \"uint256\", name: \"nonce\" },\n        { type: \"bytes\", name: \"initCode\" },\n        { type: \"bytes\", name: \"callData\" },\n        { type: \"uint256\", name: \"callGasLimit\" },\n        { type: \"uint256\", name: \"verificationGasLimit\" },\n        { type: \"uint256\", name: \"preVerificationGas\" },\n        { type: \"uint256\", name: \"maxFeePerGas\" },\n        { type: \"uint256\", name: \"maxPriorityFeePerGas\" },\n        { type: \"bytes\", name: \"paymasterAndData\" },\n        { type: \"uint48\", name: \"validAfter\" },\n        { type: \"uint48\", name: \"validUntil\" },\n        { type: \"address\", name: \"entryPoint\" }\n    ]\n}\n\nexport const EIP712_SAFE_OPERATION_TYPE_V07 = {\n    SafeOp: [\n        { type: \"address\", name: \"safe\" },\n        { type: \"uint256\", name: \"nonce\" },\n        { type: \"bytes\", name: \"initCode\" },\n        { type: \"bytes\", name: \"callData\" },\n        { type: \"uint128\", name: \"verificationGasLimit\" },\n        { type: \"uint128\", name: \"callGasLimit\" },\n        { type: \"uint256\", name: \"preVerificationGas\" },\n        { type: \"uint128\", name: \"maxPriorityFeePerGas\" },\n        { type: \"uint128\", name: \"maxFeePerGas\" },\n        { type: \"bytes\", name: \"paymasterAndData\" },\n        { type: \"uint48\", name: \"validAfter\" },\n        { type: \"uint48\", name: \"validUntil\" },\n        { type: \"address\", name: \"entryPoint\" }\n    ]\n}\n\nconst SAFE_VERSION_TO_ADDRESSES_MAP: {\n    [key in SafeVersion]: {\n        [key in \"0.6\" | \"0.7\"]: {\n            SAFE_MODULE_SETUP_ADDRESS: Address\n            SAFE_4337_MODULE_ADDRESS: Address\n            SAFE_PROXY_FACTORY_ADDRESS: Address\n            SAFE_SINGLETON_ADDRESS: Address\n            MULTI_SEND_ADDRESS: Address\n            MULTI_SEND_CALL_ONLY_ADDRESS: Address\n        }\n    }\n} = {\n    \"1.4.1\": {\n        \"0.6\": {\n            SAFE_MODULE_SETUP_ADDRESS:\n                \"0x8EcD4ec46D4D2a6B64fE960B3D64e8B94B2234eb\",\n            SAFE_4337_MODULE_ADDRESS:\n                \"0xa581c4A4DB7175302464fF3C06380BC3270b4037\",\n            SAFE_PROXY_FACTORY_ADDRESS:\n                \"0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67\",\n            SAFE_SINGLETON_ADDRESS:\n                \"0x41675C099F32341bf84BFc5382aF534df5C7461a\",\n            MULTI_SEND_ADDRESS: \"0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526\",\n            MULTI_SEND_CALL_ONLY_ADDRESS:\n                \"0x9641d764fc13c8B624c04430C7356C1C7C8102e2\"\n        },\n        \"0.7\": {\n            SAFE_MODULE_SETUP_ADDRESS:\n                \"0x2dd68b007B46fBe91B9A7c3EDa5A7a1063cB5b47\",\n            SAFE_4337_MODULE_ADDRESS:\n                \"0x75cf11467937ce3F2f357CE24ffc3DBF8fD5c226\",\n            SAFE_PROXY_FACTORY_ADDRESS:\n                \"0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67\",\n            SAFE_SINGLETON_ADDRESS:\n                \"0x41675C099F32341bf84BFc5382aF534df5C7461a\",\n            MULTI_SEND_ADDRESS: \"0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526\",\n            MULTI_SEND_CALL_ONLY_ADDRESS:\n                \"0x9641d764fc13c8B624c04430C7356C1C7C8102e2\"\n        }\n    }\n}\n\nconst adjustVInSignature = (\n    signingMethod: \"eth_sign\" | \"eth_signTypedData\",\n    signature: string\n): Hex => {\n    const ETHEREUM_V_VALUES = [0, 1, 27, 28]\n    const MIN_VALID_V_VALUE_FOR_SAFE_ECDSA = 27\n    let signatureV = Number.parseInt(signature.slice(-2), 16)\n    if (!ETHEREUM_V_VALUES.includes(signatureV)) {\n        throw new Error(\"Invalid signature\")\n    }\n    if (signingMethod === \"eth_sign\") {\n        if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {\n            signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA\n        }\n        signatureV += 4\n    }\n    if (signingMethod === \"eth_signTypedData\") {\n        if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {\n            signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA\n        }\n    }\n    return (signature.slice(0, -2) + signatureV.toString(16)) as Hex\n}\n\nconst generateSafeMessageMessage = <\n    const TTypedData extends TypedData | { [key: string]: unknown },\n    TPrimaryType extends keyof TTypedData | \"EIP712Domain\" = keyof TTypedData\n>(\n    message: SignableMessage | TypedDataDefinition<TTypedData, TPrimaryType>\n): Hex => {\n    const signableMessage = message as SignableMessage\n\n    if (typeof signableMessage === \"string\" || signableMessage.raw) {\n        return hashMessage(signableMessage)\n    }\n\n    return hashTypedData(\n        message as TypedDataDefinition<TTypedData, TPrimaryType>\n    )\n}\n\nconst encodeInternalTransaction = (tx: {\n    to: Address\n    data: Address\n    value: bigint\n    operation: 0 | 1\n}): string => {\n    const encoded = encodePacked(\n        // uint8 = 1 byte for operation\n        // address = 20 bytes for to address\n        // uint256 = 32 bytes for value\n        // uint256 = 32 bytes for data length\n        // bytes = dynamic length for data\n        [\"uint8\", \"address\", \"uint256\", \"uint256\", \"bytes\"],\n        [\n            tx.operation,\n            tx.to,\n            tx.value,\n            BigInt(tx.data.slice(2).length / 2),\n            tx.data\n        ]\n    )\n    return encoded.slice(2)\n}\n\nconst encodeMultiSend = (\n    txs: {\n        to: Address\n        data: Address\n        value: bigint\n        operation: 0 | 1\n    }[]\n): `0x${string}` => {\n    const data: `0x${string}` = `0x${txs\n        .map((tx) => encodeInternalTransaction(tx))\n        .join(\"\")}`\n\n    return encodeFunctionData({\n        abi: multiSendAbi,\n        functionName: \"multiSend\",\n        args: [data]\n    })\n}\n\nconst get7579LaunchPadInitData = ({\n    safe4337ModuleAddress,\n    safeSingletonAddress,\n    erc7579LaunchpadAddress,\n    owners,\n    validators,\n    executors,\n    fallbacks,\n    hooks,\n    attesters,\n    threshold,\n    attestersThreshold\n}: {\n    safe4337ModuleAddress: Address\n    safeSingletonAddress: Address\n    erc7579LaunchpadAddress: Address\n    owners: Address[]\n    executors: {\n        address: Address\n        context: Address\n    }[]\n    validators: { address: Address; context: Address }[]\n    fallbacks: { address: Address; context: Address }[]\n    hooks: { address: Address; context: Address }[]\n    attesters: Address[]\n    threshold: bigint\n    attestersThreshold: number\n}) => {\n    const initData = {\n        singleton: safeSingletonAddress,\n        owners: owners,\n        threshold: threshold,\n        setupTo: erc7579LaunchpadAddress,\n        setupData: encodeFunctionData({\n            abi: initSafe7579Abi,\n            functionName: \"initSafe7579\",\n            args: [\n                safe4337ModuleAddress, // SAFE_7579_ADDRESS,\n                executors.map((executor) => ({\n                    module: executor.address,\n                    initData: executor.context\n                })),\n                fallbacks.map((fallback) => ({\n                    module: fallback.address,\n                    initData: fallback.context\n                })),\n                hooks.map((hook) => ({\n                    module: hook.address,\n                    initData: hook.context\n                })),\n                attesters,\n                attestersThreshold\n            ]\n        }),\n        safe7579: safe4337ModuleAddress,\n        validators: validators\n    }\n\n    return initData\n}\n\nconst getInitializerCode = async ({\n    owners,\n    threshold,\n    safeModuleSetupAddress,\n    safe4337ModuleAddress,\n    multiSendAddress,\n    safeSingletonAddress,\n    erc7579LaunchpadAddress,\n    setupTransactions = [],\n    safeModules = [],\n    validators = [],\n    executors = [],\n    fallbacks = [],\n    hooks = [],\n    attesters = [],\n    attestersThreshold = 0,\n    paymentToken = zeroAddress,\n    payment = BigInt(0),\n    paymentReceiver = zeroAddress\n}: {\n    owners: Address[]\n    threshold: bigint\n    safeSingletonAddress: Address\n    safeModuleSetupAddress: Address\n    safe4337ModuleAddress: Address\n    multiSendAddress: Address\n    erc7579LaunchpadAddress?: Address\n    setupTransactions?: {\n        to: Address\n        data: Address\n        value: bigint\n    }[]\n    safeModules?: Address[]\n    validators?: { address: Address; context: Address }[]\n    executors?: {\n        address: Address\n        context: Address\n    }[]\n    fallbacks?: { address: Address; context: Address }[]\n    hooks?: { address: Address; context: Address }[]\n    attesters?: Address[]\n    attestersThreshold?: number\n    paymentToken?: Address\n    payment?: bigint\n    paymentReceiver?: Address\n}) => {\n    if (erc7579LaunchpadAddress) {\n        const initData = get7579LaunchPadInitData({\n            safe4337ModuleAddress,\n            safeSingletonAddress,\n            erc7579LaunchpadAddress,\n            owners,\n            validators,\n            executors,\n            fallbacks,\n            threshold,\n            hooks,\n            attesters,\n            attestersThreshold\n        })\n\n        const initHash = keccak256(\n            encodeAbiParameters(\n                [\n                    {\n                        internalType: \"address\",\n                        name: \"singleton\",\n                        type: \"address\"\n                    },\n                    {\n                        internalType: \"address[]\",\n                        name: \"owners\",\n                        type: \"address[]\"\n                    },\n                    {\n                        internalType: \"uint256\",\n                        name: \"threshold\",\n                        type: \"uint256\"\n                    },\n                    {\n                        internalType: \"address\",\n                        name: \"setupTo\",\n                        type: \"address\"\n                    },\n                    {\n                        internalType: \"bytes\",\n                        name: \"setupData\",\n                        type: \"bytes\"\n                    },\n                    {\n                        internalType: \"contract ISafe7579\",\n                        name: \"safe7579\",\n                        type: \"address\"\n                    },\n                    {\n                        internalType: \"struct ModuleInit[]\",\n                        name: \"validators\",\n                        type: \"tuple[]\",\n                        components: [\n                            {\n                                internalType: \"address\",\n                                name: \"module\",\n                                type: \"address\"\n                            },\n                            {\n                                internalType: \"bytes\",\n                                name: \"initData\",\n                                type: \"bytes\"\n                            }\n                        ]\n                    }\n                ],\n                [\n                    initData.singleton,\n                    initData.owners,\n                    initData.threshold,\n                    initData.setupTo,\n                    initData.setupData,\n                    initData.safe7579,\n                    initData.validators.map((validator) => ({\n                        module: validator.address,\n                        initData: validator.context\n                    }))\n                ]\n            )\n        )\n\n        return encodeFunctionData({\n            abi: preValidationSetupAbi,\n            functionName: \"preValidationSetup\",\n            args: [initHash, zeroAddress, \"0x\"]\n        })\n    }\n\n    const multiSendCallData = encodeMultiSend([\n        {\n            to: safeModuleSetupAddress,\n            data: encodeFunctionData({\n                abi: enableModulesAbi,\n                functionName: \"enableModules\",\n                args: [[safe4337ModuleAddress, ...safeModules]]\n            }),\n            value: BigInt(0),\n            operation: 1\n        },\n        ...setupTransactions.map((tx) => ({ ...tx, operation: 0 as 0 | 1 }))\n    ])\n\n    return encodeFunctionData({\n        abi: setupAbi,\n        functionName: \"setup\",\n        args: [\n            owners,\n            BigInt(1),\n            multiSendAddress,\n            multiSendCallData,\n            safe4337ModuleAddress,\n            paymentToken,\n            payment,\n            paymentReceiver\n        ]\n    })\n}\n\nexport function getPaymasterAndData(unpackedUserOperation: UserOperation) {\n    return unpackedUserOperation.paymaster\n        ? concat([\n              unpackedUserOperation.paymaster,\n              pad(\n                  toHex(\n                      unpackedUserOperation.paymasterVerificationGasLimit ||\n                          BigInt(0)\n                  ),\n                  {\n                      size: 16\n                  }\n              ),\n              pad(\n                  toHex(\n                      unpackedUserOperation.paymasterPostOpGasLimit || BigInt(0)\n                  ),\n                  {\n                      size: 16\n                  }\n              ),\n              unpackedUserOperation.paymasterData || (\"0x\" as Hex)\n          ])\n        : \"0x\"\n}\n\nconst getAccountInitCode = async ({\n    owners,\n    threshold,\n    safeModuleSetupAddress,\n    safe4337ModuleAddress,\n    safeSingletonAddress,\n    erc7579LaunchpadAddress,\n    multiSendAddress,\n    paymentToken,\n    payment,\n    paymentReceiver,\n    saltNonce = BigInt(0),\n    setupTransactions = [],\n    safeModules = [],\n    validators = [],\n    executors = [],\n    fallbacks = [],\n    hooks = [],\n    attesters = [],\n    attestersThreshold = 0\n}: {\n    owners: Address[]\n    threshold: bigint\n    safeModuleSetupAddress: Address\n    safe4337ModuleAddress: Address\n    safeSingletonAddress: Address\n    multiSendAddress: Address\n    erc7579LaunchpadAddress?: Address\n    saltNonce?: bigint\n    setupTransactions?: {\n        to: Address\n        data: Address\n        value: bigint\n    }[]\n    safeModules?: Address[]\n    validators?: { address: Address; context: Address }[]\n    executors?: {\n        address: Address\n        context: Address\n    }[]\n    fallbacks?: { address: Address; context: Address }[]\n    hooks?: { address: Address; context: Address }[]\n    attesters?: Address[]\n    attestersThreshold?: number\n    paymentToken?: Address\n    payment?: bigint\n    paymentReceiver?: Address\n}): Promise<Hex> => {\n    const initializer = await getInitializerCode({\n        owners,\n        threshold,\n        safeModuleSetupAddress,\n        safe4337ModuleAddress,\n        multiSendAddress,\n        setupTransactions,\n        safeSingletonAddress,\n        safeModules,\n        erc7579LaunchpadAddress,\n        validators,\n        executors,\n        fallbacks,\n        hooks,\n        attesters,\n        attestersThreshold,\n        paymentToken,\n        payment,\n        paymentReceiver\n    })\n\n    const initCodeCallData = encodeFunctionData({\n        abi: createProxyWithNonceAbi,\n        functionName: \"createProxyWithNonce\",\n        args: [\n            erc7579LaunchpadAddress ?? safeSingletonAddress,\n            initializer,\n            saltNonce\n        ]\n    })\n\n    return initCodeCallData\n}\n\nexport const getDefaultAddresses = (\n    safeVersion: SafeVersion,\n    entryPointVersion: \"0.6\" | \"0.7\",\n    {\n        addModuleLibAddress: _addModuleLibAddress,\n        safeModuleSetupAddress: _safeModuleSetupAddress,\n        safe4337ModuleAddress: _safe4337ModuleAddress,\n        safeProxyFactoryAddress: _safeProxyFactoryAddress,\n        safeSingletonAddress: _safeSingletonAddress,\n        multiSendAddress: _multiSendAddress,\n        multiSendCallOnlyAddress: _multiSendCallOnlyAddress\n    }: {\n        addModuleLibAddress?: Address\n        safeModuleSetupAddress?: Address\n        safe4337ModuleAddress?: Address\n        safeProxyFactoryAddress?: Address\n        safeSingletonAddress?: Address\n        multiSendAddress?: Address\n        multiSendCallOnlyAddress?: Address\n    }\n) => {\n    const safeModuleSetupAddress =\n        _safeModuleSetupAddress ??\n        _addModuleLibAddress ??\n        SAFE_VERSION_TO_ADDRESSES_MAP[safeVersion][entryPointVersion]\n            .SAFE_MODULE_SETUP_ADDRESS\n    const safe4337ModuleAddress =\n        _safe4337ModuleAddress ??\n        SAFE_VERSION_TO_ADDRESSES_MAP[safeVersion][entryPointVersion]\n            .SAFE_4337_MODULE_ADDRESS\n    const safeProxyFactoryAddress =\n        _safeProxyFactoryAddress ??\n        SAFE_VERSION_TO_ADDRESSES_MAP[safeVersion][entryPointVersion]\n            .SAFE_PROXY_FACTORY_ADDRESS\n    const safeSingletonAddress =\n        _safeSingletonAddress ??\n        SAFE_VERSION_TO_ADDRESSES_MAP[safeVersion][entryPointVersion]\n            .SAFE_SINGLETON_ADDRESS\n    const multiSendAddress =\n        _multiSendAddress ??\n        SAFE_VERSION_TO_ADDRESSES_MAP[safeVersion][entryPointVersion]\n            .MULTI_SEND_ADDRESS\n\n    const multiSendCallOnlyAddress =\n        _multiSendCallOnlyAddress ??\n        SAFE_VERSION_TO_ADDRESSES_MAP[safeVersion][entryPointVersion]\n            .MULTI_SEND_CALL_ONLY_ADDRESS\n\n    return {\n        safeModuleSetupAddress,\n        safe4337ModuleAddress,\n        safeProxyFactoryAddress,\n        safeSingletonAddress,\n        multiSendAddress,\n        multiSendCallOnlyAddress\n    }\n}\n\ntype GetErc7579Params<TErc7579 extends Address | undefined> =\n    TErc7579 extends undefined\n        ? {\n              safeModuleSetupAddress?: Address\n              multiSendAddress?: Address\n              multiSendCallOnlyAddress?: Address\n              // @deprecated This field is deprecated. It is recommended to make any setup transactions in the userOperation's calldata.\n              setupTransactions?: {\n                  to: Address\n                  data: Address\n                  value: bigint\n              }[]\n              safeModules?: Address[]\n          }\n        : {\n              validators?: { address: Address; context: Address }[]\n              executors?: {\n                  address: Address\n                  context: Address\n              }[]\n              fallbacks?: { address: Address; context: Address }[]\n              hooks?: { address: Address; context: Address }[]\n              attesters?: Address[]\n              attestersThreshold?: number\n          }\n\nexport type ToSafeSmartAccountParameters<\n    entryPointVersion extends \"0.6\" | \"0.7\",\n    TErc7579 extends Address | undefined\n> = {\n    client: Client\n    owners: (\n        | Account\n        | WalletClient<Transport, Chain | undefined, Account>\n        | EthereumProvider\n    )[]\n    threshold?: bigint\n    version: SafeVersion\n    entryPoint?: {\n        address: Address\n        version: entryPointVersion\n    }\n    safe4337ModuleAddress?: Address\n    erc7579LaunchpadAddress?: TErc7579\n    safeProxyFactoryAddress?: Address\n    safeSingletonAddress?: Address\n    address?: Address\n    saltNonce?: bigint\n    validUntil?: number\n    validAfter?: number\n    nonceKey?: bigint\n    paymentToken?: Address\n    payment?: bigint\n    paymentReceiver?: Address\n    onchainIdentifier?: Hex\n} & GetErc7579Params<TErc7579>\n\nfunction isErc7579Args<entryPointVersion extends \"0.6\" | \"0.7\" = \"0.7\">(\n    args: ToSafeSmartAccountParameters<entryPointVersion, Address | undefined>\n): args is ToSafeSmartAccountParameters<entryPointVersion, Address> {\n    return args.erc7579LaunchpadAddress !== undefined\n}\n\nconst proxyCreationCodeAbi = [\n    {\n        inputs: [],\n        name: \"proxyCreationCode\",\n        outputs: [\n            {\n                internalType: \"bytes\",\n                name: \"\",\n                type: \"bytes\"\n            }\n        ],\n        stateMutability: \"pure\",\n        type: \"function\"\n    }\n] as const\n\nconst getAccountAddress = async ({\n    client,\n    owners,\n    threshold,\n    safeModuleSetupAddress,\n    safe4337ModuleAddress,\n    safeProxyFactoryAddress,\n    safeSingletonAddress,\n    multiSendAddress,\n    erc7579LaunchpadAddress,\n    paymentToken,\n    payment,\n    paymentReceiver,\n    setupTransactions = [],\n    safeModules = [],\n    saltNonce = BigInt(0),\n    validators = [],\n    executors = [],\n    fallbacks = [],\n    hooks = [],\n    attesters = [],\n    attestersThreshold = 0\n}: {\n    client: Client\n    owners: Address[]\n    threshold: bigint\n    safeModuleSetupAddress: Address\n    safe4337ModuleAddress: Address\n    safeProxyFactoryAddress: Address\n    safeSingletonAddress: Address\n    multiSendAddress: Address\n    setupTransactions: {\n        to: Address\n        data: Address\n        value: bigint\n    }[]\n    paymentToken?: Address\n    payment?: bigint\n    paymentReceiver?: Address\n    safeModules?: Address[]\n    saltNonce?: bigint\n    erc7579LaunchpadAddress?: Address\n    validators?: { address: Address; context: Address }[]\n    executors?: {\n        address: Address\n        context: Address\n    }[]\n    fallbacks?: { address: Address; context: Address }[]\n    hooks?: { address: Address; context: Address }[]\n    attesters?: Address[]\n    attestersThreshold?: number\n}): Promise<Address> => {\n    const proxyCreationCode = await readContract(client, {\n        abi: proxyCreationCodeAbi,\n        address: safeProxyFactoryAddress,\n        functionName: \"proxyCreationCode\"\n    })\n\n    const initializer = await getInitializerCode({\n        owners,\n        threshold,\n        safeModuleSetupAddress,\n        safe4337ModuleAddress,\n        multiSendAddress,\n        setupTransactions,\n        safeSingletonAddress,\n        safeModules,\n        erc7579LaunchpadAddress,\n        validators,\n        executors,\n        fallbacks,\n        hooks,\n        attesters,\n        attestersThreshold,\n        paymentToken,\n        payment,\n        paymentReceiver\n    })\n\n    const deploymentCode = encodePacked(\n        [\"bytes\", \"uint256\"],\n        [\n            proxyCreationCode,\n            hexToBigInt(erc7579LaunchpadAddress ?? safeSingletonAddress)\n        ]\n    )\n\n    const salt = keccak256(\n        encodePacked(\n            [\"bytes32\", \"uint256\"],\n            [keccak256(encodePacked([\"bytes\"], [initializer])), saltNonce]\n        )\n    )\n\n    return getContractAddress({\n        from: safeProxyFactoryAddress,\n        salt,\n        bytecode: deploymentCode,\n        opcode: \"CREATE2\"\n    })\n}\n\nexport type SafeSmartAccountImplementation<\n    entryPointVersion extends \"0.6\" | \"0.7\" = \"0.7\"\n> = Assign<\n    SmartAccountImplementation<\n        entryPointVersion extends \"0.6\"\n            ? typeof entryPoint06Abi\n            : typeof entryPoint07Abi,\n        entryPointVersion\n        // {\n        //     // entryPoint === ENTRYPOINT_ADDRESS_V06 ? \"0.2.2\" : \"0.3.0-beta\"\n        //     abi: entryPointVersion extends \"0.6\" ? typeof BiconomyAbi\n        //     factory: { abi: typeof FactoryAbi; address: Address }\n        // }\n    >,\n    { sign: NonNullable<SmartAccountImplementation[\"sign\"]> }\n>\n\nexport type ToSafeSmartAccountReturnType<\n    entryPointVersion extends \"0.6\" | \"0.7\" = \"0.7\"\n> = SmartAccount<SafeSmartAccountImplementation<entryPointVersion>>\n\n/**\n * @description Creates an Simple Account from a private key.\n *\n * @returns A Private Key Simple Account.\n */\nexport async function toSafeSmartAccount<\n    entryPointVersion extends \"0.6\" | \"0.7\",\n    TErc7579 extends Address | undefined\n>(\n    parameters: ToSafeSmartAccountParameters<entryPointVersion, TErc7579>\n): Promise<ToSafeSmartAccountReturnType<entryPointVersion>> {\n    const {\n        client,\n        owners: _owners,\n        address,\n        threshold = BigInt(_owners.length),\n        version,\n        safe4337ModuleAddress: _safe4337ModuleAddress,\n        safeProxyFactoryAddress: _safeProxyFactoryAddress,\n        safeSingletonAddress: _safeSingletonAddress,\n        erc7579LaunchpadAddress,\n        saltNonce = BigInt(0),\n        validUntil = 0,\n        validAfter = 0,\n        nonceKey,\n        paymentToken,\n        payment,\n        paymentReceiver,\n        onchainIdentifier\n    } = parameters\n\n    const owners = await Promise.all(\n        _owners.map(async (owner) => {\n            if (\"account\" in owner) {\n                return owner.account\n            }\n\n            if (\"request\" in owner) {\n                return toOwner({\n                    owner: owner as EthereumProvider\n                })\n            }\n\n            return owner\n        })\n    )\n\n    const localOwners = await Promise.all(\n        _owners\n            .filter((owner) => {\n                if (\"type\" in owner && owner.type === \"local\") {\n                    return true\n                }\n\n                if (\"request\" in owner) {\n                    return true\n                }\n\n                if (\"account\" in owner) {\n                    // walletClient\n                    return true\n                }\n\n                return false\n            })\n            .map((owner) =>\n                toOwner({\n                    owner: owner as OneOf<\n                        | LocalAccount\n                        | EthereumProvider\n                        | WalletClient<Transport, Chain | undefined, Account>\n                    >\n                })\n            )\n    )\n\n    const entryPoint = {\n        address: parameters.entryPoint?.address ?? entryPoint07Address,\n        abi:\n            (parameters.entryPoint?.version ?? \"0.7\") === \"0.6\"\n                ? entryPoint06Abi\n                : entryPoint07Abi,\n        version: parameters.entryPoint?.version ?? \"0.7\"\n    } as const\n\n    let _safeModuleSetupAddress: Address | undefined = undefined\n    let _multiSendAddress: Address | undefined = undefined\n    let _multiSendCallOnlyAddress: Address | undefined = undefined\n    let safeModules: Address[] | undefined = undefined\n    let setupTransactions: {\n        to: Address\n        data: Hex\n        value: bigint\n    }[] = []\n    let validators: { address: Address; context: Address }[] = []\n    let executors: { address: Address; context: Address }[] = []\n    let fallbacks: { address: Address; context: Address }[] = []\n    let hooks: { address: Address; context: Address }[] = []\n    let attesters: Address[] = []\n    let attestersThreshold = 0\n\n    if (!isErc7579Args(parameters)) {\n        _safeModuleSetupAddress = parameters.safeModuleSetupAddress\n        _multiSendAddress = parameters.multiSendAddress\n        _multiSendCallOnlyAddress = parameters.multiSendCallOnlyAddress\n        safeModules = parameters.safeModules\n        setupTransactions = parameters.setupTransactions ?? []\n    }\n\n    if (isErc7579Args(parameters)) {\n        validators = parameters.validators ?? []\n        executors = parameters.executors ?? []\n        fallbacks = parameters.fallbacks ?? []\n        hooks = parameters.hooks ?? []\n        attesters = parameters.attesters ?? []\n        attestersThreshold = parameters.attestersThreshold ?? 0\n    }\n\n    const {\n        safeModuleSetupAddress,\n        safe4337ModuleAddress,\n        safeProxyFactoryAddress,\n        safeSingletonAddress,\n        multiSendAddress,\n        multiSendCallOnlyAddress\n    } = getDefaultAddresses(version, entryPoint.version, {\n        safeModuleSetupAddress: _safeModuleSetupAddress,\n        safe4337ModuleAddress: _safe4337ModuleAddress,\n        safeProxyFactoryAddress: _safeProxyFactoryAddress,\n        safeSingletonAddress: _safeSingletonAddress,\n        multiSendAddress: _multiSendAddress,\n        multiSendCallOnlyAddress: _multiSendCallOnlyAddress\n    })\n\n    let accountAddress: Address | undefined = address\n\n    let chainId: number\n\n    const getMemoizedChainId = async () => {\n        if (chainId) return chainId\n        chainId = client.chain\n            ? client.chain.id\n            : await getAction(client, getChainId, \"getChainId\")({})\n        return chainId\n    }\n\n    const getFactoryArgs = async () => {\n        return {\n            factory: safeProxyFactoryAddress,\n            factoryData: await getAccountInitCode({\n                owners: owners.map((owner) => owner.address),\n                threshold,\n                safeModuleSetupAddress,\n                safe4337ModuleAddress,\n                safeSingletonAddress,\n                multiSendAddress,\n                erc7579LaunchpadAddress,\n                saltNonce,\n                setupTransactions,\n                safeModules,\n                validators,\n                executors,\n                fallbacks,\n                hooks,\n                attesters,\n                attestersThreshold,\n                paymentToken,\n                payment,\n                paymentReceiver\n            })\n        }\n    }\n\n    return toSmartAccount({\n        client,\n        entryPoint,\n        getFactoryArgs,\n        async getAddress() {\n            if (accountAddress) return accountAddress\n\n            // Get the sender address based on the init code\n            accountAddress = await getAccountAddress({\n                client,\n                owners: owners.map((owner) => owner.address),\n                threshold,\n                safeModuleSetupAddress,\n                safe4337ModuleAddress,\n                safeProxyFactoryAddress,\n                safeSingletonAddress,\n                multiSendAddress,\n                erc7579LaunchpadAddress,\n                saltNonce,\n                setupTransactions,\n                safeModules,\n                validators,\n                executors,\n                fallbacks,\n                hooks,\n                attesters,\n                attestersThreshold,\n                paymentToken,\n                payment,\n                paymentReceiver\n            })\n\n            return accountAddress\n        },\n        async encodeCalls(calls) {\n            const hasMultipleCalls = calls.length > 1\n\n            if (erc7579LaunchpadAddress) {\n                const safeDeployed = await isSmartAccountDeployed(\n                    client,\n                    await this.getAddress()\n                )\n\n                if (!safeDeployed) {\n                    const initData = get7579LaunchPadInitData({\n                        safe4337ModuleAddress,\n                        safeSingletonAddress,\n                        erc7579LaunchpadAddress,\n                        owners: owners.map((owner) => owner.address),\n                        threshold,\n                        validators,\n                        executors,\n                        fallbacks,\n                        hooks,\n                        attesters,\n                        attestersThreshold\n                    })\n\n                    return encodeFunctionData({\n                        abi: setupSafeAbi,\n                        functionName: \"setupSafe\",\n                        args: [\n                            {\n                                ...initData,\n                                validators: initData.validators.map(\n                                    (validator) => ({\n                                        module: validator.address,\n                                        initData: validator.context\n                                    })\n                                ),\n                                callData: encode7579Calls({\n                                    mode: {\n                                        type: hasMultipleCalls\n                                            ? \"batchcall\"\n                                            : \"call\",\n                                        revertOnError: false,\n                                        selector: \"0x\",\n                                        context: \"0x\"\n                                    },\n                                    callData: calls\n                                })\n                            }\n                        ]\n                    })\n                }\n\n                return encode7579Calls({\n                    mode: {\n                        type: hasMultipleCalls ? \"batchcall\" : \"call\",\n                        revertOnError: false,\n                        selector: \"0x\",\n                        context: \"0x\"\n                    },\n                    callData: calls\n                })\n            }\n\n            let to: Address\n            let value: bigint\n            let data: Hex\n            let operationType = 0\n\n            if (hasMultipleCalls) {\n                to = multiSendCallOnlyAddress\n                value = BigInt(0)\n\n                data = encodeMultiSend(\n                    calls.map((tx) => ({\n                        to: tx.to,\n                        value: tx.value ?? 0n,\n                        data: tx.data ?? \"0x\",\n                        operation: 0\n                    }))\n                )\n                operationType = 1\n            } else {\n                const call = calls.length === 0 ? undefined : calls[0]\n\n                if (!call) {\n                    throw new Error(\"No calls to encode\")\n                }\n\n                to = call.to\n                data = call.data ?? \"0x\"\n                value = call.value ?? 0n\n            }\n\n            const calldata = encodeFunctionData({\n                abi: executeUserOpWithErrorStringAbi,\n                functionName: \"executeUserOpWithErrorString\",\n                args: [to, value, data, operationType]\n            })\n\n            if (onchainIdentifier) {\n                return concat([calldata, onchainIdentifier])\n            }\n\n            return calldata\n        },\n        async decodeCalls(callData) {\n            try {\n                const decoded = decodeFunctionData({\n                    abi: setupSafeAbi,\n                    data: callData\n                })\n\n                return decode7579Calls(decoded.args[0].callData).callData\n            } catch (_) {}\n\n            try {\n                return decode7579Calls(callData).callData\n            } catch (_) {}\n\n            const decoded = decodeFunctionData({\n                abi: executeUserOpWithErrorStringAbi,\n                data: callData\n            })\n\n            const to = decoded.args[0]\n            const value = decoded.args[1]\n            const data = decoded.args[2]\n\n            if (to === multiSendCallOnlyAddress) {\n                const decodedMultiSend = decodeFunctionData({\n                    abi: multiSendAbi,\n                    data: data\n                })\n\n                const dataToDecode = decodedMultiSend.args[0]\n                const transactions: {\n                    to: Address\n                    value: bigint\n                    data: Hex\n                }[] = []\n\n                let position = 0\n                const dataLength = size(dataToDecode)\n\n                while (position < dataLength) {\n                    // skip the operation type\n                    position += 1\n\n                    const to = getAddress(\n                        slice(dataToDecode, position, position + 20)\n                    )\n                    position += 20\n\n                    const value = BigInt(\n                        slice(dataToDecode, position, position + 32)\n                    )\n                    position += 32\n\n                    const dataLength = Number(\n                        BigInt(slice(dataToDecode, position, position + 32)) *\n                            BigInt(2)\n                    )\n\n                    position += 32\n\n                    const data = slice(\n                        dataToDecode,\n                        position,\n                        position + dataLength\n                    )\n                    position += dataLength\n\n                    transactions.push({ to, value, data })\n                }\n\n                return transactions\n            }\n\n            return [{ to, value, data }]\n        },\n        async getNonce(args) {\n            return getAccountNonce(client, {\n                address: await this.getAddress(),\n                entryPointAddress: entryPoint.address,\n                key: nonceKey ?? args?.key\n            })\n        },\n        async getStubSignature() {\n            return encodePacked(\n                [\"uint48\", \"uint48\", \"bytes\"],\n                [\n                    0,\n                    0,\n                    `0x${owners\n                        .map(\n                            (_) =>\n                                \"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"\n                        )\n                        .join(\"\")}`\n                ]\n            )\n        },\n        async sign({ hash }) {\n            return this.signMessage({ message: hash })\n        },\n        async signMessage({ message }) {\n            if (localOwners.length !== owners.length) {\n                throw new Error(\n                    \"Owners length mismatch, currently not supported\"\n                )\n            }\n\n            const messageHash = hashTypedData({\n                domain: {\n                    chainId: await getMemoizedChainId(),\n                    verifyingContract: await this.getAddress()\n                },\n                types: {\n                    SafeMessage: [{ name: \"message\", type: \"bytes\" }]\n                },\n                primaryType: \"SafeMessage\",\n                message: {\n                    message: generateSafeMessageMessage(message)\n                }\n            })\n\n            const signatures = await Promise.all(\n                localOwners.map(async (localOwner) => ({\n                    signer: localOwner.address,\n                    data: adjustVInSignature(\n                        \"eth_sign\",\n                        await localOwner.signMessage({\n                            message: {\n                                raw: toBytes(messageHash)\n                            }\n                        })\n                    )\n                }))\n            )\n\n            signatures.sort((left, right) =>\n                left.signer\n                    .toLowerCase()\n                    .localeCompare(right.signer.toLowerCase())\n            )\n\n            const signatureBytes = concat(signatures.map((sig) => sig.data))\n\n            return erc7579LaunchpadAddress\n                ? concat([zeroAddress, signatureBytes])\n                : signatureBytes\n        },\n        async signTypedData(typedData) {\n            if (localOwners.length !== owners.length) {\n                throw new Error(\n                    \"Owners length mismatch, currently not supported\"\n                )\n            }\n\n            const signatures = await Promise.all(\n                localOwners.map(async (localOwner) => ({\n                    signer: localOwner.address,\n                    data: adjustVInSignature(\n                        \"eth_signTypedData\",\n\n                        await localOwner.signTypedData({\n                            domain: {\n                                chainId: await getMemoizedChainId(),\n                                verifyingContract: await this.getAddress()\n                            },\n                            types: {\n                                SafeMessage: [\n                                    { name: \"message\", type: \"bytes\" }\n                                ]\n                            },\n                            primaryType: \"SafeMessage\",\n                            message: {\n                                message: generateSafeMessageMessage(typedData)\n                            }\n                        })\n                    )\n                }))\n            )\n\n            signatures.sort((left, right) =>\n                left.signer\n                    .toLowerCase()\n                    .localeCompare(right.signer.toLowerCase())\n            )\n\n            const signatureBytes = concat(signatures.map((sig) => sig.data))\n\n            return erc7579LaunchpadAddress\n                ? concat([zeroAddress, signatureBytes])\n                : signatureBytes\n        },\n        async signUserOperation(parameters) {\n            const { chainId = await getMemoizedChainId(), ...userOperation } =\n                parameters\n\n            if (localOwners.length !== owners.length) {\n                throw new Error(\n                    \"Owners length mismatch use SafeSmartAccount.signUserOperation from `permissionless/accounts/safe`\"\n                )\n            }\n\n            let signatures: Hex | undefined = undefined\n\n            for (const owner of localOwners) {\n                signatures = await signUserOperation({\n                    ...userOperation,\n                    version,\n                    entryPoint,\n                    owners: localOwners,\n                    account: owner as OneOf<\n                        | EthereumProvider\n                        | WalletClient<Transport, Chain | undefined, Account>\n                        | LocalAccount\n                    >,\n                    chainId: await getMemoizedChainId(),\n                    signatures,\n                    validAfter,\n                    validUntil,\n                    safe4337ModuleAddress\n                })\n            }\n\n            if (!signatures) {\n                throw new Error(\"No signatures found\")\n            }\n\n            return signatures\n        }\n    }) as Promise<ToSafeSmartAccountReturnType<entryPointVersion>>\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2199, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2205, "column": 0}, "map": {"version":3,"file":"sendTransaction.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/actions/smartAccount/sendTransaction.ts"],"sourcesContent":["import type {\n    Chain,\n    Client,\n    Hash,\n    SendTransactionParameters,\n    Transport\n} from \"viem\"\nimport {\n    type SendUserOperationParameters,\n    type SmartAccount,\n    sendUserOperation,\n    waitForUserOperationReceipt\n} from \"viem/account-abstraction\"\nimport { getAction, parseAccount } from \"viem/utils\"\nimport { AccountNotFoundError } from \"../../errors/index.js\"\n\n/**\n * Creates, signs, and sends a new transaction to the network.\n * This function also allows you to sponsor this transaction if sender is a smartAccount\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/sending-transactions\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n *\n * @param client - Client to use\n * @param parameters - {@link SendTransactionParameters}\n * @returns The [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash.\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await sendTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const hash = await sendTransaction(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n */\nexport async function sendTransaction<\n    account extends SmartAccount | undefined,\n    chain extends Chain | undefined,\n    accountOverride extends SmartAccount | undefined = undefined,\n    chainOverride extends Chain | undefined = Chain | undefined,\n    calls extends readonly unknown[] = readonly unknown[]\n>(\n    client: Client<Transport, chain, account>,\n    args:\n        | SendTransactionParameters<chain, account, chainOverride>\n        | SendUserOperationParameters<account, accountOverride, calls>\n): Promise<Hash> {\n    let userOpHash: Hash\n\n    if (\"to\" in args) {\n        const {\n            account: account_ = client.account,\n            data,\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n            to,\n            value,\n            nonce\n        } = args\n\n        if (!account_) {\n            throw new AccountNotFoundError({\n                docsPath: \"/docs/actions/wallet/sendTransaction\"\n            })\n        }\n\n        const account = parseAccount(account_) as SmartAccount\n\n        if (!to) throw new Error(\"Missing to address\")\n\n        userOpHash = await getAction(\n            client,\n            sendUserOperation,\n            \"sendUserOperation\"\n        )({\n            calls: [\n                {\n                    to,\n                    value: value || BigInt(0),\n                    data: data || \"0x\"\n                }\n            ],\n            account,\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n            nonce: nonce ? BigInt(nonce) : undefined\n        })\n    } else {\n        userOpHash = await getAction(\n            client,\n            sendUserOperation,\n            \"sendUserOperation\"\n        )({ ...args } as SendUserOperationParameters<account, accountOverride>)\n    }\n\n    const userOperationReceipt = await getAction(\n        client,\n        waitForUserOperationReceipt,\n        \"waitForUserOperationReceipt\"\n    )({\n        hash: userOpHash\n    })\n\n    return userOperationReceipt?.receipt.transactionHash\n}\n"],"names":[],"mappings":";;;AAcA,OAAO,EAAE,oBAAoB,EAAE,MAAM,uBAAuB,CAAA;AAD5D,OAAO,EAAE,SAAS,EAAE,YAAY,EAAE,MAAM,YAAY,CAAA;;;AANpD,OAAO,EAGH,iBAAiB,EACjB,2BAA2B,EAC9B,MAAM,0BAA0B,CAAA;;;;AAkD1B,KAAK,UAAU,eAAe,CAOjC,MAAyC,EACzC,IAEkE;IAElE,IAAI,UAAgB,CAAA;IAEpB,IAAI,IAAI,IAAI,IAAI,EAAE,CAAC;QACf,MAAM,EACF,OAAO,EAAE,QAAQ,GAAG,MAAM,CAAC,OAAO,EAClC,IAAI,EACJ,YAAY,EACZ,oBAAoB,EACpB,EAAE,EACF,KAAK,EACL,KAAK,EACR,GAAG,IAAI,CAAA;QAER,IAAI,CAAC,QAAQ,EAAE,CAAC;YACZ,MAAM,IAAI,oLAAoB,CAAC;gBAC3B,QAAQ,EAAE,sCAAsC;aACnD,CAAC,CAAA;QACN,CAAC;QAED,MAAM,OAAO,4KAAG,eAAA,AAAY,EAAC,QAAQ,CAAiB,CAAA;QAEtD,IAAI,CAAC,EAAE,EAAE,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAA;QAE9C,UAAU,GAAG,gKAAM,YAAA,AAAS,EACxB,MAAM,uMACN,oBAAiB,EACjB,mBAAmB,CACtB,CAAC;YACE,KAAK,EAAE;gBACH;oBACI,EAAE;oBACF,KAAK,EAAE,KAAK,IAAI,MAAM,CAAC,CAAC,CAAC;oBACzB,IAAI,EAAE,IAAI,IAAI,IAAI;iBACrB;aACJ;YACD,OAAO;YACP,YAAY;YACZ,oBAAoB;YACpB,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS;SAC3C,CAAC,CAAA;IACN,CAAC,MAAM,CAAC;QACJ,UAAU,GAAG,gKAAM,YAAS,AAAT,EACf,MAAM,uMACN,oBAAiB,EACjB,mBAAmB,CACtB,CAAC;YAAE,GAAG,IAAI;QAAA,CAA2D,CAAC,CAAA;IAC3E,CAAC;IAED,MAAM,oBAAoB,GAAG,gKAAM,YAAS,AAAT,EAC/B,MAAM,iNACN,8BAA2B,EAC3B,6BAA6B,CAChC,CAAC;QACE,IAAI,EAAE,UAAU;KACnB,CAAC,CAAA;IAEF,OAAO,oBAAoB,EAAE,OAAO,CAAC,eAAe,CAAA;AACxD,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2250, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2256, "column": 0}, "map": {"version":3,"file":"signMessage.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/actions/smartAccount/signMessage.ts"],"sourcesContent":["import type {\n    Chain,\n    Client,\n    SignMessageParameters,\n    SignMessageReturnType,\n    Transport\n} from \"viem\"\nimport type { SmartAccount } from \"viem/account-abstraction\"\nimport { parseAccount } from \"viem/utils\"\nimport { AccountNotFoundError } from \"../../errors/index.js\"\n\n/**\n * Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/signMessage.html\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`personal_sign`](https://docs.metamask.io/guide/signing-data.html#personal-sign)\n *   - Local Accounts: Signs locally. No JSON-RPC request.\n *\n * With the calculated signature, you can:\n * - use [`verifyMessage`](https://viem.sh/docs/utilities/verifyMessage.html) to verify the signature,\n * - use [`recoverMessageAddress`](https://viem.sh/docs/utilities/recoverMessageAddress.html) to recover the signing address from a signature.\n *\n * @param client - Client to use\n * @param parameters - {@link SignMessageParameters}\n * @returns The signed message. {@link SignMessageReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { signMessage } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signMessage(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   message: 'hello world',\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, custom } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signMessage } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signMessage(client, {\n *   message: 'hello world',\n * })\n */\nexport async function signMessage<TAccount extends SmartAccount | undefined>(\n    client: Client<Transport, Chain | undefined, TAccount>,\n    {\n        account: account_ = client.account,\n        message\n    }: SignMessageParameters<TAccount>\n): Promise<SignMessageReturnType> {\n    if (!account_)\n        throw new AccountNotFoundError({\n            docsPath: \"/docs/actions/wallet/signMessage\"\n        })\n\n    const account = parseAccount(account_) as SmartAccount\n\n    return account.signMessage({ message })\n}\n"],"names":[],"mappings":";;;AASA,OAAO,EAAE,oBAAoB,EAAE,MAAM,uBAAuB,CAAA;AAD5D,OAAO,EAAE,YAAY,EAAE,MAAM,YAAY,CAAA;;;AAiDlC,KAAK,UAAU,WAAW,CAC7B,MAAsD,EACtD,EACI,OAAO,EAAE,QAAQ,GAAG,MAAM,CAAC,OAAO,EAClC,OAAO,EACuB;IAElC,IAAI,CAAC,QAAQ,EACT,MAAM,iKAAI,uBAAoB,CAAC;QAC3B,QAAQ,EAAE,kCAAkC;KAC/C,CAAC,CAAA;IAEN,MAAM,OAAO,4KAAG,eAAA,AAAY,EAAC,QAAQ,CAAiB,CAAA;IAEtD,OAAO,OAAO,CAAC,WAAW,CAAC;QAAE,OAAO;IAAA,CAAE,CAAC,CAAA;AAC3C,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2272, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2278, "column": 0}, "map": {"version":3,"file":"signTypedData.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/actions/smartAccount/signTypedData.ts"],"sourcesContent":["import {\n    type Chain,\n    type Client,\n    type SignTypedDataParameters,\n    type SignTypedDataReturnType,\n    type Transport,\n    type TypedData,\n    type TypedDataDefinition,\n    type TypedDataDomain,\n    getTypesForEIP712Domain,\n    validateTypedData\n} from \"viem\"\nimport type { SmartAccount } from \"viem/account-abstraction\"\nimport { parseAccount } from \"viem/utils\"\nimport { AccountNotFoundError } from \"../../errors/index.js\"\n\n/**\n * Signs typed data and calculates an Ethereum-specific signature in [https://eips.ethereum.org/EIPS/eip-712](https://eips.ethereum.org/EIPS/eip-712): `sign(keccak256(\"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)))`\n *\n * - Docs: https://viem.sh/docs/actions/wallet/signTypedData.html\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data.html#signtypeddata-v4)\n *   - Local Accounts: Signs locally. No JSON-RPC request.\n *\n * @param client - Client to use\n * @param parameters - {@link SignTypedDataParameters}\n * @returns The signed data. {@link SignTypedDataReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { signTypedData } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signTypedData(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signTypedData } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const signature = await signTypedData(client, {\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n */\nexport async function signTypedData<\n    const TTypedData extends TypedData | { [key: string]: unknown },\n    TPrimaryType extends string,\n    TAccount extends SmartAccount | undefined = SmartAccount | undefined\n>(\n    client: Client<Transport, Chain | undefined, TAccount>,\n    {\n        account: account_ = client.account,\n        domain,\n        message,\n        primaryType,\n        types: types_\n    }: SignTypedDataParameters<TTypedData, TPrimaryType, TAccount>\n): Promise<SignTypedDataReturnType> {\n    if (!account_) {\n        throw new AccountNotFoundError({\n            docsPath: \"/docs/actions/wallet/signMessage\"\n        })\n    }\n\n    const account = parseAccount(account_) as SmartAccount\n\n    const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain } as {\n            domain: TypedDataDomain\n        }),\n        ...(types_ as TTypedData)\n    }\n\n    validateTypedData({\n        domain,\n        message,\n        primaryType,\n        types\n    } as TypedDataDefinition)\n\n    return account.signTypedData({\n        domain,\n        primaryType,\n        types,\n        message\n    } as TypedDataDefinition)\n}\n"],"names":[],"mappings":";;;AAcA,OAAO,EAAE,oBAAoB,EAAE,MAAM,uBAAuB,CAAA;AAD5D,OAAO,EAAE,YAAY,EAAE,MAAM,YAAY,CAAA;AAbzC,OAAO,EASH,uBAAuB,EACvB,iBAAiB,EACpB,MAAM,MAAM,CAAA;;;;AAuGN,KAAK,UAAU,aAAa,CAK/B,MAAsD,EACtD,EACI,OAAO,EAAE,QAAQ,GAAG,MAAM,CAAC,OAAO,EAClC,MAAM,EACN,OAAO,EACP,WAAW,EACX,KAAK,EAAE,MAAM,EAC6C;IAE9D,IAAI,CAAC,QAAQ,EAAE,CAAC;QACZ,MAAM,iKAAI,uBAAoB,CAAC;YAC3B,QAAQ,EAAE,kCAAkC;SAC/C,CAAC,CAAA;IACN,CAAC;IAED,MAAM,OAAO,4KAAG,eAAA,AAAY,EAAC,QAAQ,CAAiB,CAAA;IAEtD,MAAM,KAAK,GAAG;QACV,YAAY,4JAAE,0BAAA,AAAuB,EAAC;YAAE,MAAM;QAAA,CAE7C,CAAC;QACF,GAAI,MAAqB;KAC5B,CAAA;8JAED,oBAAA,AAAiB,EAAC;QACd,MAAM;QACN,OAAO;QACP,WAAW;QACX,KAAK;KACe,CAAC,CAAA;IAEzB,OAAO,OAAO,CAAC,aAAa,CAAC;QACzB,MAAM;QACN,WAAW;QACX,KAAK;QACL,OAAO;KACa,CAAC,CAAA;AAC7B,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2313, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2319, "column": 0}, "map": {"version":3,"file":"writeContract.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/actions/smartAccount/writeContract.ts"],"sourcesContent":["import {\n    type Abi,\n    type Chain,\n    type Client,\n    type ContractFunctionArgs,\n    type ContractFunctionName,\n    type EncodeFunctionDataParameters,\n    type Hash,\n    type SendTransactionParameters,\n    type Transport,\n    type WriteContractParameters,\n    encodeFunctionData\n} from \"viem\"\nimport type { SmartAccount } from \"viem/account-abstraction\"\nimport { getAction } from \"viem/utils\"\nimport { sendTransaction } from \"./sendTransaction.js\"\n\nexport async function writeContract<\n    TChain extends Chain | undefined,\n    TAccount extends SmartAccount | undefined,\n    const TAbi extends Abi | readonly unknown[],\n    TFunctionName extends ContractFunctionName<\n        TAbi,\n        \"nonpayable\" | \"payable\"\n    > = ContractFunctionName<TAbi, \"nonpayable\" | \"payable\">,\n    TArgs extends ContractFunctionArgs<\n        TAbi,\n        \"nonpayable\" | \"payable\",\n        TFunctionName\n    > = ContractFunctionArgs<TAbi, \"nonpayable\" | \"payable\", TFunctionName>,\n    TChainOverride extends Chain | undefined = undefined\n>(\n    client: Client<Transport, TChain, TAccount>,\n    {\n        abi,\n        address,\n        args,\n        dataSuffix,\n        functionName,\n        ...request\n    }: WriteContractParameters<\n        TAbi,\n        TFunctionName,\n        TArgs,\n        TChain,\n        TAccount,\n        TChainOverride\n    >\n): Promise<Hash> {\n    const data = encodeFunctionData<TAbi, TFunctionName>({\n        abi,\n        args,\n        functionName\n    } as EncodeFunctionDataParameters<TAbi, TFunctionName>)\n\n    const hash = await getAction(\n        client,\n        sendTransaction<TAccount, undefined, undefined>,\n        \"sendTransaction\"\n    )({\n        data: `${data}${dataSuffix ? dataSuffix.replace(\"0x\", \"\") : \"\"}`,\n        to: address,\n        ...request\n    } as unknown as SendTransactionParameters<\n        Chain | undefined,\n        TAccount,\n        undefined\n    >)\n    return hash\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAWH,kBAAkB,EACrB,MAAM,MAAM,CAAA;AAEb,OAAO,EAAE,SAAS,EAAE,MAAM,YAAY,CAAA;AACtC,OAAO,EAAE,eAAe,EAAE,MAAM,sBAAsB,CAAA;;;;AAE/C,KAAK,UAAU,aAAa,CAe/B,MAA2C,EAC3C,EACI,GAAG,EACH,OAAO,EACP,IAAI,EACJ,UAAU,EACV,YAAY,EACZ,GAAG,OAAO,EAQb;IAED,MAAM,IAAI,6KAAG,qBAAA,AAAkB,EAAsB;QACjD,GAAG;QACH,IAAI;QACJ,YAAY;KACsC,CAAC,CAAA;IAEvD,MAAM,IAAI,GAAG,OAAM,qKAAA,AAAS,EACxB,MAAM,EACN,wLAAA,kBAA+C,CAAA,CAC/C,iBAAiB,CACpB,CAAC;QACE,IAAI,EAAE,GAAG,IAAI,GAAG,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE;QAChE,EAAE,EAAE,OAAO;QACX,GAAG,OAAO;KAKb,CAAC,CAAA;IACF,OAAO,IAAI,CAAA;AACf,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2341, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2347, "column": 0}, "map": {"version":3,"file":"smartAccount.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/clients/decorators/smartAccount.ts"],"sourcesContent":["import type {\n    Abi,\n    Chain,\n    Client,\n    ContractFunctionArgs,\n    ContractFunctionName,\n    Hash,\n    SendTransactionParameters,\n    Transport,\n    TypedData,\n    WriteContractParameters\n} from \"viem\"\nimport type { SmartAccount } from \"viem/account-abstraction\"\nimport { sendTransaction } from \"../../actions/smartAccount/sendTransaction.js\"\nimport { signMessage } from \"../../actions/smartAccount/signMessage.js\"\nimport { signTypedData } from \"../../actions/smartAccount/signTypedData.js\"\nimport { writeContract } from \"../../actions/smartAccount/writeContract.js\"\n\nexport type SmartAccountActions<\n    TChain extends Chain | undefined = Chain | undefined,\n    TSmartAccount extends SmartAccount | undefined = SmartAccount | undefined\n> = {\n    /**\n     * Creates, signs, and sends a new transaction to the network.\n     * This function also allows you to sponsor this transaction if sender is a smartAccount\n     *\n     * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction.html\n     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/sending-transactions\n     * - JSON-RPC Methods:\n     *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n     *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n     *\n     * @param args - {@link SendTransactionParameters}\n     * @returns The [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. {@link SendTransactionReturnType}\n     *\n     * @example\n     * import { createWalletClient, custom } from 'viem'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const client = createWalletClient({\n     *   chain: mainnet,\n     *   transport: custom(window.ethereum),\n     * })\n     * const hash = await client.sendTransaction({\n     *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n     *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n     *   value: 1000000000000000000n,\n     * })\n     *\n     * @example\n     * // Account Hoisting\n     * import { createWalletClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const client = createWalletClient({\n     *   account: privateKeyToAccount('0x…'),\n     *   chain: mainnet,\n     *   transport: http(),\n     * })\n     * const hash = await client.sendTransaction({\n     *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n     *   value: 1000000000000000000n,\n     * })\n     */\n    sendTransaction: <\n        TChainOverride extends Chain | undefined = undefined,\n        accountOverride extends SmartAccount | undefined = undefined,\n        calls extends readonly unknown[] = readonly unknown[]\n    >(\n        args: Parameters<\n            typeof sendTransaction<\n                TSmartAccount,\n                TChain,\n                accountOverride,\n                TChainOverride,\n                calls\n            >\n        >[1]\n    ) => Promise<Hash>\n    /**\n     * Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n     *\n     * - Docs: https://viem.sh/docs/actions/wallet/signMessage.html\n     * - JSON-RPC Methods:\n     *   - JSON-RPC Accounts: [`personal_sign`](https://docs.metamask.io/guide/signing-data.html#personal-sign)\n     *   - Local Accounts: Signs locally. No JSON-RPC request.\n     *\n     * With the calculated signature, you can:\n     * - use [`verifyMessage`](https://viem.sh/docs/utilities/verifyMessage.html) to verify the signature,\n     * - use [`recoverMessageAddress`](https://viem.sh/docs/utilities/recoverMessageAddress.html) to recover the signing address from a signature.\n     *\n     * @param args - {@link SignMessageParameters}\n     * @returns The signed message. {@link SignMessageReturnType}\n     *\n     * @example\n     * import { createWalletClient, custom } from 'viem'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const client = createWalletClient({\n     *   chain: mainnet,\n     *   transport: custom(window.ethereum),\n     * })\n     * const signature = await client.signMessage({\n     *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n     *   message: 'hello world',\n     * })\n     *\n     * @example\n     * // Account Hoisting\n     * import { createWalletClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const client = createWalletClient({\n     *   account: privateKeyToAccount('0x…'),\n     *   chain: mainnet,\n     *   transport: http(),\n     * })\n     * const signature = await client.signMessage({\n     *   message: 'hello world',\n     * })\n     */\n    signMessage: (\n        args: Parameters<typeof signMessage<TSmartAccount>>[1]\n    ) => ReturnType<typeof signMessage<TSmartAccount>>\n    /**\n     * Signs typed data and calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n     *\n     * - Docs: https://viem.sh/docs/actions/wallet/signTypedData.html\n     * - JSON-RPC Methods:\n     *   - JSON-RPC Accounts: [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data.html#signtypeddata-v4)\n     *   - Local Accounts: Signs locally. No JSON-RPC request.\n     *\n     * @param client - Client to use\n     * @param args - {@link SignTypedDataParameters}\n     * @returns The signed data. {@link SignTypedDataReturnType}\n     *\n     * @example\n     * import { createWalletClient, custom } from 'viem'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const client = createWalletClient({\n     *   chain: mainnet,\n     *   transport: custom(window.ethereum),\n     * })\n     * const signature = await client.signTypedData({\n     *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n     *   domain: {\n     *     name: 'Ether Mail',\n     *     version: '1',\n     *     chainId: 1,\n     *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n     *   },\n     *   types: {\n     *     Person: [\n     *       { name: 'name', type: 'string' },\n     *       { name: 'wallet', type: 'address' },\n     *     ],\n     *     Mail: [\n     *       { name: 'from', type: 'Person' },\n     *       { name: 'to', type: 'Person' },\n     *       { name: 'contents', type: 'string' },\n     *     ],\n     *   },\n     *   primaryType: 'Mail',\n     *   message: {\n     *     from: {\n     *       name: 'Cow',\n     *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n     *     },\n     *     to: {\n     *       name: 'Bob',\n     *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n     *     },\n     *     contents: 'Hello, Bob!',\n     *   },\n     * })\n     *\n     * @example\n     * // Account Hoisting\n     * import { createWalletClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const client = createWalletClient({\n     *   account: privateKeyToAccount('0x…'),\n     *   chain: mainnet,\n     *   transport: http(),\n     * })\n     * const signature = await client.signTypedData({\n     *   domain: {\n     *     name: 'Ether Mail',\n     *     version: '1',\n     *     chainId: 1,\n     *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n     *   },\n     *   types: {\n     *     Person: [\n     *       { name: 'name', type: 'string' },\n     *       { name: 'wallet', type: 'address' },\n     *     ],\n     *     Mail: [\n     *       { name: 'from', type: 'Person' },\n     *       { name: 'to', type: 'Person' },\n     *       { name: 'contents', type: 'string' },\n     *     ],\n     *   },\n     *   primaryType: 'Mail',\n     *   message: {\n     *     from: {\n     *       name: 'Cow',\n     *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n     *     },\n     *     to: {\n     *       name: 'Bob',\n     *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n     *     },\n     *     contents: 'Hello, Bob!',\n     *   },\n     * })\n     */\n    signTypedData: <\n        const TTypedData extends TypedData | { [key: string]: unknown },\n        TPrimaryType extends string\n    >(\n        args: Parameters<\n            typeof signTypedData<TTypedData, TPrimaryType, TSmartAccount>\n        >[1]\n    ) => ReturnType<\n        typeof signTypedData<TTypedData, TPrimaryType, TSmartAccount>\n    >\n    /**\n     * Executes a write function on a contract.\n     * This function also allows you to sponsor this transaction if sender is a smartAccount\n     *\n     * - Docs: https://viem.sh/docs/contract/writeContract.html\n     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/writing-to-contracts\n     *\n     * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms.html) is needed to be broadcast in order to change the state.\n     *\n     * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet.html) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).\n     *\n     * __Warning: The `write` internally sends a transaction – it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract.html#usage) before you execute it.__\n     *\n     * @param args - {@link WriteContractParameters}\n     * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms.html#hash). {@link WriteContractReturnType}\n     *\n     * @example\n     * import { createWalletClient, custom, parseAbi } from 'viem'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const client = createWalletClient({\n     *   chain: mainnet,\n     *   transport: custom(window.ethereum),\n     * })\n     * const hash = await client.writeContract({\n     *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n     *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n     *   functionName: 'mint',\n     *   args: [69420],\n     * })\n     *\n     * @example\n     * // With Validation\n     * import { createWalletClient, custom, parseAbi } from 'viem'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const client = createWalletClient({\n     *   chain: mainnet,\n     *   transport: custom(window.ethereum),\n     * })\n     * const { request } = await client.simulateContract({\n     *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n     *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n     *   functionName: 'mint',\n     *   args: [69420],\n     * }\n     * const hash = await client.writeContract(request)\n     */\n    writeContract: <\n        const TAbi extends Abi | readonly unknown[],\n        TFunctionName extends ContractFunctionName<\n            TAbi,\n            \"nonpayable\" | \"payable\"\n        > = ContractFunctionName<TAbi, \"nonpayable\" | \"payable\">,\n        TArgs extends ContractFunctionArgs<\n            TAbi,\n            \"nonpayable\" | \"payable\",\n            TFunctionName\n        > = ContractFunctionArgs<TAbi, \"nonpayable\" | \"payable\", TFunctionName>,\n        TChainOverride extends Chain | undefined = undefined\n    >(\n        args: WriteContractParameters<\n            TAbi,\n            TFunctionName,\n            TArgs,\n            TChain,\n            TSmartAccount,\n            TChainOverride\n        >\n    ) => ReturnType<\n        typeof writeContract<\n            TChain,\n            TSmartAccount,\n            TAbi,\n            TFunctionName,\n            TArgs,\n            TChainOverride\n        >\n    >\n}\n\nexport function smartAccountActions<\n    TChain extends Chain | undefined = Chain | undefined,\n    TSmartAccount extends SmartAccount | undefined = SmartAccount | undefined\n>(\n    client: Client<Transport, TChain, TSmartAccount>\n): SmartAccountActions<TChain, TSmartAccount> {\n    return {\n        sendTransaction: (args) => sendTransaction(client, args as any),\n        signMessage: (args) => signMessage(client, args),\n        signTypedData: (args) => signTypedData(client, args),\n        writeContract: (args) => writeContract(client, args)\n    }\n}\n"],"names":[],"mappings":";;;AAaA,OAAO,EAAE,eAAe,EAAE,MAAM,+CAA+C,CAAA;AAC/E,OAAO,EAAE,WAAW,EAAE,MAAM,2CAA2C,CAAA;AACvE,OAAO,EAAE,aAAa,EAAE,MAAM,6CAA6C,CAAA;AAC3E,OAAO,EAAE,aAAa,EAAE,MAAM,6CAA6C,CAAA;;;;;AAySrE,SAAU,mBAAmB,CAI/B,MAAgD;IAEhD,OAAO;QACH,eAAe,EAAE,CAAC,IAAI,EAAE,EAAE,2LAAC,kBAAA,AAAe,EAAC,MAAM,EAAE,IAAW,CAAC;QAC/D,WAAW,EAAE,CAAC,IAAI,EAAE,EAAE,AAAC,qMAAA,AAAW,EAAC,MAAM,EAAE,IAAI,CAAC;QAChD,aAAa,EAAE,CAAC,IAAI,EAAE,EAAE,yLAAC,gBAAA,AAAa,EAAC,MAAM,EAAE,IAAI,CAAC;QACpD,aAAa,EAAE,CAAC,IAAI,EAAE,EAAE,yLAAC,gBAAA,AAAa,EAAC,MAAM,EAAE,IAAI,CAAC;KACvD,CAAA;AACL,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2366, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2372, "column": 0}, "map": {"version":3,"file":"createSmartAccountClient.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/permissionless/clients/createSmartAccountClient.ts"],"sourcesContent":["import {\n    type BundlerRpcSchema,\n    type Chain,\n    type Client,\n    type ClientConfig,\n    type EstimateFeesPerGasReturnType,\n    type Prettify,\n    type RpcSchema,\n    type Transport,\n    createClient\n} from \"viem\"\nimport {\n    type BundlerActions,\n    type BundlerClientConfig,\n    type PaymasterActions,\n    type PrepareUserOperationParameters,\n    type SmartAccount,\n    type UserOperationRequest,\n    bundlerActions,\n    type prepareUserOperation as viemPrepareUserOperation\n} from \"viem/account-abstraction\"\nimport {\n    type SmartAccountActions,\n    smartAccountActions\n} from \"./decorators/smartAccount.js\"\n\n/**\n * TODO:\n *  - Add docs\n *  - Fix typing, 'accounts' is required to signMessage, signTypedData, signTransaction, but not needed here, since account is embedded in the client\n */\nexport type SmartAccountClient<\n    transport extends Transport = Transport,\n    chain extends Chain | undefined = Chain | undefined,\n    account extends SmartAccount | undefined = SmartAccount | undefined,\n    client extends Client | undefined = Client | undefined,\n    rpcSchema extends RpcSchema | undefined = undefined\n> = Prettify<\n    Client<\n        transport,\n        chain extends Chain\n            ? chain\n            : client extends Client<any, infer chain>\n              ? chain\n              : undefined,\n        account,\n        rpcSchema extends RpcSchema\n            ? [...BundlerRpcSchema, ...rpcSchema]\n            : BundlerRpcSchema,\n        BundlerActions<account> & SmartAccountActions<chain, account>\n    >\n> & {\n    client: client\n    paymaster: BundlerClientConfig[\"paymaster\"] | undefined\n    paymasterContext: BundlerClientConfig[\"paymasterContext\"] | undefined\n    userOperation: BundlerClientConfig[\"userOperation\"] | undefined\n}\n\nexport type SmartAccountClientConfig<\n    transport extends Transport = Transport,\n    chain extends Chain | undefined = Chain | undefined,\n    account extends SmartAccount | undefined = SmartAccount | undefined,\n    client extends Client | undefined = Client | undefined,\n    rpcSchema extends RpcSchema | undefined = undefined\n> = Prettify<\n    Pick<\n        ClientConfig<transport, chain, account, rpcSchema>,\n        | \"account\"\n        | \"cacheTime\"\n        | \"chain\"\n        | \"key\"\n        | \"name\"\n        | \"pollingInterval\"\n        | \"rpcSchema\"\n    >\n> & {\n    bundlerTransport: transport\n    /** Client that points to an Execution RPC URL. */\n    client?: client | Client | undefined\n    /** Paymaster configuration. */\n    paymaster?:\n        | true\n        | {\n              /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n              getPaymasterData?:\n                  | PaymasterActions[\"getPaymasterData\"]\n                  | undefined\n              /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n              getPaymasterStubData?:\n                  | PaymasterActions[\"getPaymasterStubData\"]\n                  | undefined\n          }\n        | undefined\n    /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n    paymasterContext?: unknown\n    /** User Operation configuration. */\n    userOperation?:\n        | {\n              /** Prepares fee properties for the User Operation request. */\n              estimateFeesPerGas?:\n                  | ((parameters: {\n                        account: account | SmartAccount\n                        bundlerClient: Client\n                        userOperation: UserOperationRequest\n                    }) => Promise<EstimateFeesPerGasReturnType<\"eip1559\">>)\n                  | undefined\n              /** Prepare User Operation configuration. */\n              prepareUserOperation?: typeof viemPrepareUserOperation | undefined\n          }\n        | undefined\n}\n\nexport function createSmartAccountClient<\n    transport extends Transport,\n    chain extends Chain | undefined = undefined,\n    account extends SmartAccount | undefined = undefined,\n    client extends Client | undefined = undefined,\n    rpcSchema extends RpcSchema | undefined = undefined\n>(\n    parameters: SmartAccountClientConfig<\n        transport,\n        chain,\n        account,\n        client,\n        rpcSchema\n    >\n): SmartAccountClient<transport, chain, account, client, rpcSchema>\n\nexport function createSmartAccountClient(\n    parameters: SmartAccountClientConfig\n): SmartAccountClient {\n    const {\n        client: client_,\n        key = \"bundler\",\n        name = \"Bundler Client\",\n        paymaster,\n        paymasterContext,\n        bundlerTransport,\n        userOperation\n    } = parameters\n\n    const client = Object.assign(\n        createClient({\n            ...parameters,\n            chain: parameters.chain ?? client_?.chain,\n            transport: bundlerTransport,\n            key,\n            name,\n            type: \"bundlerClient\" // TODO: is this okay?\n        }),\n        { client: client_, paymaster, paymasterContext, userOperation }\n    )\n\n    if (parameters.userOperation?.prepareUserOperation) {\n        const customPrepareUserOp =\n            parameters.userOperation.prepareUserOperation\n\n        return client\n            .extend(bundlerActions)\n            .extend((client) => ({\n                prepareUserOperation: (\n                    args: PrepareUserOperationParameters\n                ) => {\n                    return customPrepareUserOp(client, args)\n                }\n            }))\n            .extend(bundlerActions)\n            .extend((client) => ({\n                prepareUserOperation: (\n                    args: PrepareUserOperationParameters\n                ) => {\n                    return customPrepareUserOp(client, args)\n                }\n            }))\n            .extend(smartAccountActions) as SmartAccountClient\n    }\n\n    return client\n        .extend(bundlerActions)\n        .extend(smartAccountActions) as SmartAccountClient\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EASH,YAAY,EACf,MAAM,MAAM,CAAA;AACb,OAAO,EAOH,cAAc,EAEjB,MAAM,0BAA0B,CAAA;AACjC,OAAO,EAEH,mBAAmB,EACtB,MAAM,8BAA8B,CAAA;;;;AAwG/B,SAAU,wBAAwB,CACpC,UAAoC;IAEpC,MAAM,EACF,MAAM,EAAE,OAAO,EACf,GAAG,GAAG,SAAS,EACf,IAAI,GAAG,gBAAgB,EACvB,SAAS,EACT,gBAAgB,EAChB,gBAAgB,EAChB,aAAa,EAChB,GAAG,UAAU,CAAA;IAEd,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,gKACxB,eAAA,AAAY,EAAC;QACT,GAAG,UAAU;QACb,KAAK,EAAE,UAAU,CAAC,KAAK,IAAI,OAAO,EAAE,KAAK;QACzC,SAAS,EAAE,gBAAgB;QAC3B,GAAG;QACH,IAAI;QACJ,IAAI,EAAE,eAAe,CAAC,sBAAsB;KAC/C,CAAC,EACF;QAAE,MAAM,EAAE,OAAO;QAAE,SAAS;QAAE,gBAAgB;QAAE,aAAa;IAAA,CAAE,CAClE,CAAA;IAED,IAAI,UAAU,CAAC,aAAa,EAAE,oBAAoB,EAAE,CAAC;QACjD,MAAM,mBAAmB,GACrB,UAAU,CAAC,aAAa,CAAC,oBAAoB,CAAA;QAEjD,OAAO,MAAM,CACR,MAAM,+LAAC,iBAAc,CAAC,CACtB,MAAM,CAAC,CAAC,MAAM,EAAE,CAAG,CAAD,AAAE;gBACjB,oBAAoB,EAAE,CAClB,IAAoC,EACtC,EAAE;oBACA,OAAO,mBAAmB,CAAC,MAAM,EAAE,IAAI,CAAC,CAAA;gBAC5C,CAAC;aACJ,CAAC,CAAC,CACF,MAAM,+LAAC,iBAAc,CAAC,CACtB,MAAM,CAAC,CAAC,MAAM,EAAE,CAAG,CAAC,AAAF;gBACf,oBAAoB,EAAE,CAClB,IAAoC,EACtC,EAAE;oBACA,OAAO,mBAAmB,CAAC,MAAM,EAAE,IAAI,CAAC,CAAA;gBAC5C,CAAC;aACJ,CAAC,CAAC,CACF,MAAM,oLAAC,sBAAmB,CAAuB,CAAA;IAC1D,CAAC;IAED,OAAO,MAAM,CACR,MAAM,+LAAC,iBAAc,CAAC,CACtB,MAAM,oLAAC,sBAAmB,CAAuB,CAAA;AAC1D,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2410, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}