{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 167, "column": 0}, "map": {"version":3,"sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/src/app/api/guides/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport { Agent } from '@fileverse/agents'\nimport axios from 'axios'\n\nasync function serverLog(message: string) {\n  try {\n    await fetch('http://localhost:3000/api/logs', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        log: {\n          timestamp: new Date().toISOString(),\n          message\n        }\n      })\n    })\n  } catch (error) {\n    console.error('Failed to store log:', error)\n  }\n}\n\nasync function fetchIpfsContent(ipfsHash: string): Promise<any> {\n  const hash = ipfsHash.replace('ipfs://', '')\n  const gateway = process.env.PINATA_GATEWAY\n  const jwt = process.env.PINATA_JWT\n  \n  const response = await axios.get(`https://${gateway}/ipfs/${hash}`, {\n    headers: {\n      'Authorization': `Bearer ${jwt}`\n    }\n  })\n  return response.data\n}\n\nconst initAgent = () => {\n  return new Agent({ \n    chain: 'sepolia',\n    privateKey: process.env.PRIVATE_KEY!,\n    pinataJWT: process.env.PINATA_JWT!,\n    pinataGateway: process.env.PINATA_GATEWAY!,\n    pimlicoAPIKey: process.env.PIMLICO_API_KEY!,\n  })\n}\n\n// In-memory store for guides\nlet guides: Array<{\n  fileId: string;\n  title: string;\n  content: string;\n  ipfsHash: string;\n  creator: string;\n  timestamp: string;\n}> = []\n\n// Temporary function to add a guide (call this from upload API)\nexport function addGuide(guide: any) {\n  guides.push(guide)\n  console.log('Guide added to memory. Current guides:', guides)\n}\n\nexport async function GET(request: Request) {\n  console.log('GET /api/guides - Current guides in memory:', guides)\n  return NextResponse.json({ guides })\n}"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA,eAAe,UAAU,OAAe;IACtC,IAAI;QACF,MAAM,MAAM,kCAAkC;YAC5C,QAAQ;YACR,SAAS;gBAAE,gBAAgB;YAAmB;YAC9C,MAAM,KAAK,SAAS,CAAC;gBACnB,KAAK;oBACH,WAAW,IAAI,OAAO,WAAW;oBACjC;gBACF;YACF;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wBAAwB;IACxC;AACF;AAEA,eAAe,iBAAiB,QAAgB;IAC9C,MAAM,OAAO,SAAS,OAAO,CAAC,WAAW;IACzC,MAAM,UAAU,QAAQ,GAAG,CAAC,cAAc;IAC1C,MAAM,MAAM,QAAQ,GAAG,CAAC,UAAU;IAElC,MAAM,WAAW,MAAM,uIAAA,CAAA,UAAK,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,QAAQ,MAAM,EAAE,MAAM,EAAE;QAClE,SAAS;YACP,iBAAiB,CAAC,OAAO,EAAE,KAAK;QAClC;IACF;IACA,OAAO,SAAS,IAAI;AACtB;AAEA,MAAM,YAAY;IAChB,OAAO,IAAI,gJAAA,CAAA,QAAK,CAAC;QACf,OAAO;QACP,YAAY,QAAQ,GAAG,CAAC,WAAW;QACnC,WAAW,QAAQ,GAAG,CAAC,UAAU;QACjC,eAAe,QAAQ,GAAG,CAAC,cAAc;QACzC,eAAe,QAAQ,GAAG,CAAC,eAAe;IAC5C;AACF;AAEA,6BAA6B;AAC7B,IAAI,SAOC,EAAE;AAGA,SAAS,SAAS,KAAU;IACjC,OAAO,IAAI,CAAC;IACZ,QAAQ,GAAG,CAAC,0CAA0C;AACxD;AAEO,eAAe,IAAI,OAAgB;IACxC,QAAQ,GAAG,CAAC,+CAA+C;IAC3D,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;QAAE;IAAO;AACpC"}},
    {"offset": {"line": 227, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 233, "column": 0}, "map": {"version":3,"sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/src/app/api/upload/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport { Agent } from '@fileverse/agents'\nimport { addGuide } from '../guides/route'\n\n// In-memory store for guides\nlet guides: Array<{\n  fileId: string;\n  title: string;\n  content: string;\n  ipfsHash: string;\n  creator: string;\n  timestamp: string;\n}> = []\n\nconst initAgent = () => {\n  return new Agent({ \n    chain: 'sepolia',\n    privateKey: process.env.PRIVATE_KEY!,\n    pinataJWT: process.env.PINATA_JWT!,\n    pinataGateway: process.env.PINATA_GATEWAY!,\n    pimlicoAPIKey: process.env.PIMLICO_API_KEY!,\n  })\n}\n\nexport async function POST(request: Request) {\n  try {\n    const { content, action, fileId, walletAddress } = await request.json()\n    console.log('POST /api/upload - Received content:', content)\n    \n    const agent = initAgent()\n    await agent.setupStorage('Unwrit')\n\n    // Handle deletion\n    if (action === 'delete' && fileId) {\n      await agent.delete(BigInt(fileId))\n      return NextResponse.json({ success: true })\n    }\n\n    // Create new file\n    const file = await agent.create(content)\n    console.log('File created:', file)\n    \n    // Get title from content\n    const titleMatch = content.match(/^# (.*)/m)\n    const title = titleMatch ? titleMatch[1] : 'Untitled Guide'\n    const mainContent = content.replace(/^# .*\\n/, '').trim()\n\n    // Create guide object\n    const guide = {\n      fileId: file.fileId.toString(),\n      title,\n      content: mainContent,\n      ipfsHash: file.contentIpfsHash || '',\n      creator: walletAddress,\n      timestamp: new Date().toISOString()\n    }\n\n    console.log('Adding guide to memory:', guide)\n    addGuide(guide)\n\n    return NextResponse.json(guide)\n  } catch (error) {\n    console.error('Failed to upload:', error)\n    return NextResponse.json({ error: 'Failed to upload content' }, { status: 500 })\n  }\n}\n\nexport async function GET() {\n  try {\n    // Return guides from our local store\n    const formattedGuides = guides.map(guide => {\n      const titleMatch = guide.content.match(/^# (.*)/m)\n      const title = titleMatch ? titleMatch[1] : 'Untitled Guide'\n      const mainContent = guide.content.replace(/^# .*\\n/, '').trim()\n\n      return {\n        fileId: guide.fileId,\n        title,\n        content: mainContent,\n        ipfsHash: guide.ipfsHash,\n        createdAt: guide.timestamp,\n        creator: guide.creator\n      }\n    })\n\n    console.log(`Returning ${formattedGuides.length} guides from local store`)\n    return NextResponse.json({ guides: formattedGuides })\n  } catch (error) {\n    console.error('Failed to fetch guides:', error)\n    return NextResponse.json({ guides: [] })\n  }\n} "],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA,6BAA6B;AAC7B,IAAI,SAOC,EAAE;AAEP,MAAM,YAAY;IAChB,OAAO,IAAI,gJAAA,CAAA,QAAK,CAAC;QACf,OAAO;QACP,YAAY,QAAQ,GAAG,CAAC,WAAW;QACnC,WAAW,QAAQ,GAAG,CAAC,UAAU;QACjC,eAAe,QAAQ,GAAG,CAAC,cAAc;QACzC,eAAe,QAAQ,GAAG,CAAC,eAAe;IAC5C;AACF;AAEO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,aAAa,EAAE,GAAG,MAAM,QAAQ,IAAI;QACrE,QAAQ,GAAG,CAAC,wCAAwC;QAEpD,MAAM,QAAQ;QACd,MAAM,MAAM,YAAY,CAAC;QAEzB,kBAAkB;QAClB,IAAI,WAAW,YAAY,QAAQ;YACjC,MAAM,MAAM,MAAM,CAAC,OAAO;YAC1B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAAK;QAC3C;QAEA,kBAAkB;QAClB,MAAM,OAAO,MAAM,MAAM,MAAM,CAAC;QAChC,QAAQ,GAAG,CAAC,iBAAiB;QAE7B,yBAAyB;QACzB,MAAM,aAAa,QAAQ,KAAK,CAAC;QACjC,MAAM,QAAQ,aAAa,UAAU,CAAC,EAAE,GAAG;QAC3C,MAAM,cAAc,QAAQ,OAAO,CAAC,WAAW,IAAI,IAAI;QAEvD,sBAAsB;QACtB,MAAM,QAAQ;YACZ,QAAQ,KAAK,MAAM,CAAC,QAAQ;YAC5B;YACA,SAAS;YACT,UAAU,KAAK,eAAe,IAAI;YAClC,SAAS;YACT,WAAW,IAAI,OAAO,WAAW;QACnC;QAEA,QAAQ,GAAG,CAAC,2BAA2B;QACvC,CAAA,GAAA,sIAAA,CAAA,WAAQ,AAAD,EAAE;QAET,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,qBAAqB;QACnC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA2B,GAAG;YAAE,QAAQ;QAAI;IAChF;AACF;AAEO,eAAe;IACpB,IAAI;QACF,qCAAqC;QACrC,MAAM,kBAAkB,OAAO,GAAG,CAAC,CAAA;YACjC,MAAM,aAAa,MAAM,OAAO,CAAC,KAAK,CAAC;YACvC,MAAM,QAAQ,aAAa,UAAU,CAAC,EAAE,GAAG;YAC3C,MAAM,cAAc,MAAM,OAAO,CAAC,OAAO,CAAC,WAAW,IAAI,IAAI;YAE7D,OAAO;gBACL,QAAQ,MAAM,MAAM;gBACpB;gBACA,SAAS;gBACT,UAAU,MAAM,QAAQ;gBACxB,WAAW,MAAM,SAAS;gBAC1B,SAAS,MAAM,OAAO;YACxB;QACF;QAEA,QAAQ,GAAG,CAAC,CAAC,UAAU,EAAE,gBAAgB,MAAM,CAAC,wBAAwB,CAAC;QACzE,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,QAAQ;QAAgB;IACrD,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,QAAQ,EAAE;QAAC;IACxC;AACF"}},
    {"offset": {"line": 322, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}